<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RDIMM或LRDIMM适合你的设计吗？]]></title>
    <url>%2F2019%2F07%2F17%2FRDIMM%E6%88%96LRDIMM%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[DDR5 DIMM缓冲芯片正为下一代服务器/系统设计整装待发。你可以选择RDIMM或LRDIMM，但练达的设计师知道要同时保有这两者。 下一代DDR5缓冲芯片呼之欲出，服务器和系统设计人员将很快将DDR5服务器双列直插存储器模块（DIMM）缓冲芯片组纳入其新设计中。但服务器/系统设计师可能在思考的问题是：在带寄存器的DIMM（RDIMM）或减负（load-reduced）DIMM（LRDIMM）间如何取舍？了解RDIMM和LRDIMM之间基本差异非常重要，因为这些差异如何有助于指导你正确使用DIMM进行设计。某些规范对于帮助你确定要使用的DIMM也至关重要。最后，了解一些关键设计注意事项是有帮助的，它们可作为选择正确DIMM类型的基础。 下一代DDR5缓冲芯片呼之欲出，服务器和系统设计人员将很快将DDR5服务器双列直插存储器模块（DIMM）缓冲芯片组纳入他们的新设计中。但服务器/系统设计师可能在思考的问题是：在带寄存器的DIMM（RDIMM）或减少负载的（load-reduced）DIMM（LRDIMM）间如何取舍？ 简要的回答是：如果你致力高速和低延迟，那么RDIMM通常适合你。另一方面，当你的设计需要更高的内存密度时，LRDIMM是不二之选。但要使设计高效、没有短板，还有很多事情需要考虑。 服务器/系统设计达人明白：通盘考虑两者是明智之举。为什么？因为你的系统内存容量可能会随时间而变化。最初，你的系统可能没有满载，因此你可以从RDIMM开始，在相对轻载的条件下达到最高速度。但以后，你可能希望增加服务器的内存容量，因此可以使用LRDIMM以提供更大容量。 这就是为何了解RDIMM和LRDIMM之间基本差异非常重要，并了解这些差异如何有助于指导你正确使用DIMM进行设计。某些规范对于帮助你确定要使用的DIMM也至关重要。最后，了解一些关键设计注意事项是有帮助的，它们可作为选择正确DIMM类型的基础。 RDIMM或LRDIMM——选哪种？如下图所示，RDIMM上有一个带寄存器的时钟驱动器（RCD）。 RCD从主机存储器控制器获取命令地址总线、控制信号和时钟信号，然后将这些信号流扇出到DIMM上的DRAM。 DQ信号数据总线和DQ选通（DQS）直接从存储器控制器传送到DRAM封装。在RCD上缓冲的唯一操作是命令/地址总线、控制信号和DIMM的输入时钟。所有这些都在通过RCD后都会进入RDIMM上的所有DRAM，并重新计时和清理。 与早期的无缓冲DIMM（UDIMM）设计相比，采用RDIMM的设计可跑得更快。与UDIMM相比，将RCD放在RDIMM中可以帮助你加大负载，因为它可以缓冲时钟信号和命令/地址线。在RDIMM中，时钟信号和命令/地址线需要额外的驱动强度，因为它们会进入DIMM上的所有DRAM封装。相比之下，DQ和DQS信号不需要额外的驱动强度，因为它们直接从存储器控制器进入单个DRAM封装或多列DRAM封装。 此外，就RDIMM来说，了解从存储器控制器到DIMM的RCD的命令/地址总线和输入时钟是单向的很重要。相比之下，DQ总线和DQS在存储器控制器和RDIMM上的DRAM之间则是双向的。 接着看LRDIMM，如下图所示，它上面也有一个RCD，并使用多个数据缓冲区（DB）来缓冲主机内存控制器和DRAM之间的进入DQ和DQS信号。DDR5 LRDIMM有10个DBs，每个DB只处理8位数据总线。 对于DDR5，数据总线预计是两个32位通道加上一个8位纠错码（ECC）字节。因此，每个通道上有40位，LRDIMM的每一侧需要5个DBs。 DB和DRAM之间的信号称为MDQ和MDQS，以区别主机端的DQ和DQS信号。这里，主机和DRAM间数据缓冲区的好处是：如果LRDIMM上有多列DRAM，你还降低了数据总线上的负载。 此外，数据缓冲区获得8个数据位，但每半个字节有4个DQ位。对于四个位中的每一个，都有一个DQS选通位，它是差分的，而DQ位是单端的。主机存储器控制器可通过带内（in-band）命令/地址总线或通过串行管理总线对RCD进行配置。主机内存控制器不直接配置数据缓冲区，而是由RCD通过缓冲通信总线（BCOM）配置。 驾驭规范在规划DDR5设计时，DIMM规格将发挥重要作用。它们很重要，因为它们是量测缓冲芯片、时钟和/或缓冲数据信号质量的标准。你希望能够确保DRAM的输入在经过RCD或DB缓冲后没太多变化。 你还希望确认系统存储器通道时序的预算得以保证。另外，你想知道DB或RCD不会占用从内存控制器到DIMM并返回内存控制器这一往返延迟的太大部分。 就规格本身而言，RDIMM和LRDIMM的一些高阶规格是相似的。例如，速率以存储器通道上的每秒兆次传输（MT/s）来度量。对于DDR5，速率从3,200 MT/s开始、最高可达6,400 MT /s，可能更高。 此外，与DDR4一样，DIMM的内存容量以千兆字节为单位，例如8 GB，16 GB或32 GB。了解功耗也很重要。采用非常结构化的方式测量功耗，具有标准定义的工作和休眠功耗模式。对于数据缓冲区，它区分工作状态下的读、写功耗。 RDIMM上RCD的关键规范与时钟计时有关，因为RCD的主要功能是重新缓冲时钟并将其发送到DRAM。在这里，你需要了解从DIMM输入时钟到RCD输出命令/地址（CA）信号的传播延迟。该规范称为tPDM，包括发出信号的时间，而不仅仅是时钟延迟。 静态偏移（或tSTAOFF）是另一种传播延迟测量，它指的是通过RCD、从输入到输出时钟的时钟延迟。因为这是个缓冲时钟，所以你还需知道输出到DRAM的时钟的抖动量。 动态偏移（或tDYNOFF）是传播延迟的最大变化，是衡量时钟一致性的指标。这对DRAM时序很重要。 tQSK是另一种RCD测量，它是从QCA输出到时钟的偏差（skew）。 对于LRDIMM，以下是数据缓冲区的关键规范。一些重要的测量和规范还与偏差有关；但它们是从DQS或选通到DQ数据（称为tDQSQ）、或每半个字节的引脚之间DQS到DQ的偏差。 你还需要测量数据有效窗口（或tDVWp）。这决定了数据有效窗口可能的宽度，以便数据缓冲区有效处理。对于写入输入，有tDVA和tDVB规范，分别表示：数据有效前；数据有效后。它们告诉你可用于设置和保持数据缓冲区输出到DRAM的时间。 tPDM Read和tPDM Write是通过数据缓冲区的传播延迟的度量。这是针对DQ路径的，因为它是双向的，所以它们在每个方向上都是单独测量的。从主机存储器控制器的角度看：tPDM Read是从DRAM到主机的度量；tPDM Write是从主机到DRAM的度量。 接收器灵敏度是需要了解的LRDIMM数据缓冲区的另一个规范。对于DDR5，信号运行的速度比以前DDR信号要快得多。因此，你需要获得良好的测量结果，包括Vih/Vil（电压输入高电平和低电平）。 设计注意事项在RDIMM或LRDIMM之间进行选择时，DDR5 MT/s的目标速率是主要考量之一。与LRDIMM相比，RDIMM更便宜、功耗更低。如果系统内存容量不是关键要素，它们还可以实现最高速度。 LRDIMM提供更高的DRAM内存容量。因为数据位在数据缓冲区内缓冲，它们或许能支持更多的封装列。如果你需要最大化服务器中每个CPU的可用内存，LRDIMM实际上是容量大咖。当然要有代价，因为你要向LRDIMM添加10个数据缓冲区。 DIMM设计稍微复杂些。因此，与RDIMM相比，LRDIMM的成本更高，且由于额外的数据缓冲器其功耗也稍高。 摘要如前所述，RDIMM和LRDIMM都是下一代DDR5设计的可行选择。到底选哪种，取决于你的初始设计目标。如果需要性能更强的服务器设计，随着新的速度和容量需求增加，选用DDR 5 LRDIMM，则系统仍可胜任。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器,内存条</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禁止电脑版钉钉软件提示升级]]></title>
    <url>%2F2019%2F06%2F15%2F%E7%A6%81%E6%AD%A2%E7%94%B5%E8%84%91%E7%89%88%E9%92%89%E9%92%89%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[在路径 C:\Windows\System32\drivers\etc 以管理员身份打开 hosts ，添加以下内容： 1127.0.0.1 im.dingtalk.com]]></content>
      <categories>
        <category>软件设置</category>
      </categories>
      <tags>
        <tag>钉钉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言文件操作详解]]></title>
    <url>%2F2019%2F05%2F20%2FC%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[C语言中没有输入输出语句，所有的输入输出功能都用 ANSI C 提供的一组标准库函数来实现。文件操作标准库函数有： 文件的打开操作 fopen 打开一个文件 文件的关闭操作 fclose 关闭一个文件 文件的读写操作： fgetc 从文件中读取一个字符 fputc 写一个字符到文件中去 fgets 从文件中读取一个字符串 fputs 写一个字符串到文件中去 fprintf 往文件中写格式化数据 fscanf 格式化读取文件中数据 fread 以二进制形式读取文件中的数据 fwrite 以二进制形式写数据到文件中去 getw 以二进制形式读取一个整数 putw 以二进制形式存贮一个整数 文件状态检查函数 feof 文件结束 ferror 文件读、写出错 clearerr 清除文件错误标志 ftell 了解文件指针的当前位置 文件定位函数 rewind 反绕 fseek 随机定位 文件的打开函数原型1FILE *fopen(char *pname,char *mode) 功能说明按照 mode 规定的方式，打开由 pname 指定的文件。若找不到由 pname 指定的相应文件，就按以下方式之一处理： 此时如 mode 规定按写方式打开文件，就按由 pname 指定的名字建立一个新文件； 此时如 mode 规定按读方式打开文件，就会产生一个错误。 打开文件的作用是： 分配给打开文件一个 FILE 类型的文件结构体变量，并将有关信息填入文件结构体变量； 开辟一个缓冲区； 调用操作系统提供的打开文件或建立新文件功能，打开或建立指定文件； FILE *：指出 fopen 是一个返回文件类型的指针函数； 参数说明pname：是一个字符指针，它将指向要打开或建立的文件的文件名字符串。mode：是一个指向文件处理方式字符串的字符指针。 返回值正常返回：被打开文件的文件指针。异常返回：NULL，表示打开操作不成功。 例如： 12345678//定义一个名叫fp文件指针FILE *fp；//判断按读方式打开一个名叫test的文件是否失败if((fp=fopen（"test"，"r"）) == NULL)//打开操作不成功&#123; printf("The file can not be opened.\n")； exit(1);//结束程序的执行&#125; 要说明的是：C 语言将计算机的输入输出设备都看作是文件。例如，键盘文件、屏幕文件等。ANSI C 标准规定，在执行程序时系统先自动打开键盘、屏幕、错误三个文件。这三个文件的文件指针分别是：标准输入 stdin、标准输出 stdout 和标准出错 stderr。 文件的关闭函数原型1int fclose(FILE *fp)； 功能说明关闭由 fp 指出的文件。此时调用操作系统提供的文件关闭功能，关闭由 fp-&gt;fd 指出的文件；释放由 fp 指出的文件类型结构体变量；返回操作结果，即 0 或 EOF 。 参数说明fp：一个已打开文件的文件指针。 返回值正常返回：0。异常返回：EOF，表示文件在关闭时发生错误。 例如： 1int n=fclose(fp); 文件的读写操作从文件中读取一个字符函数原型1int fgetc(FILE *fp)； 功能说明从 fp 所指文件中读取一个字符。 参数说明fp：这是个文件指针，它指出要从中读取字符的文件。 返回值正常返回： 返回读取字符的代码。非正常返回：返回 EOF 。例如，要从”写打开”文件中读取一个字符时，会发生错误而返回一个 EOF 。 实例显示指定文件的内容： 1234567891011121314151617181920212223242526272829//程序名为：display.c//执行时可用：display filename1 形式的命令行运行。显示文件filename1中的内容。例如，执行命令行display display.c将在屏幕上显示display的原代码。//File display program.#include &lt;stdio.h&gt;void main(int argc,char *argv[]) //命令行参数&#123; int ch;//定义文件类型指针 FILE *fp;//判断命令行是否正确 if(argc!=2) &#123; printf("Error format,Usage: display filename1\n"); return; //键入了错误的命令行，结束程序的执行 &#125; //按读方式打开由argv[1]指出的文件 if((fp=fopen(argv[1],"r"))==NULL) &#123; printf("The file &lt;%s&gt; can not be opened.\n",argv[1]);//打开操作不成功 return;//结束程序的执行 &#125; //成功打开了argv[1]所指文件 ch=fgetc(fp); //从fp所指文件的当前指针位置读取一个字符 while(ch!=EOF) //判断刚读取的字符是否是文件结束符 &#123; putchar(ch); //若不是结束符，将它输出到屏幕上显示 ch=fgetc(fp); //继续从fp所指文件中读取下一个字符 &#125; //完成将fp所指文件的内容输出到屏幕上显示 fclose(fp); //关闭fp所指文件&#125; 写一个字符到文件中去函数原型1int fputc(int ch,FILE *fp) 功能说明把 ch 中的字符写入由 fp 指出的文件中去。 参数说明ch：是一个整型变量，内存要写到文件中的字符（C语言中整型量和字符量可以通用）。fp：这是个文件指针，指出要在其中写入字符的文件。 返回值正常返回： 要写入字符的代码。非正常返回：返回 EOF 。例如，要往”读打开”文件中写一个字符时，会发生错误而返回一个 EOF 。 实例将一个文件的内容复制到另一个文件中去： 123456789101112131415161718192021222324252627282930313233343536//程序名为：copyfile.c//执行时可用：copyfile filename1 filename2形式的命令行运行，将文件filename1中的内容复制到文件filename2中去。//file copy program.#include &lt;stdio.h&gt;void main(int argc,char *argv[]) //命令行参数&#123; int ch; FILE *in,*out; //定义in和out两个文件类型指针 if(argc!=3) //判断命令行是否正确 &#123; printf("Error in format,Usage: copyfile filename1 filename2\n"); return; //命令行错，结束程序的执行 &#125; //按读方式打开由argv[1]指出的文件 if((in=fopen(argv[1],"r"))==NULL) &#123; printf("The file &lt;%s&gt; can not be opened.\n",argv[1]); return; //打开失败，结束程序的执行 &#125; //成功打开了argv[1]所指文件，再 //按写方式打开由argv[2]指出的文件 if((out=fopen(argv[2],"w"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[2]); return; //打开失败，结束程序的执行 &#125; //成功打开了argv[2]所指文件 ch=fgetc(in); //从in所指文件的当前指针位置读取一个字符 while(ch!=EOF) //判断刚读取的字符是否是文件结束符 &#123; fputc(ch,out); //若不是结束符，将它写入out所指文件 ch=fgetc(in); //继续从in所指文件中读取下一个字符 &#125; //完成将in所指文件的内容写入（复制）到out所指文件中 fclose(in); //关闭in所指文件 fclose(out); //关闭out所指文件&#125; 实例按十进制和字符显示文件代码，若遇不可示字符就用井号”#”字符代替之： 12345678910111213141516171819202122232425262728293031323334353637383940414243//程序名为：dumpf.c//执行时可用：dumpf filename1 形式的命令行运行。// File dump program.#include &lt;stdio.h&gt;void main(int argc,char *argv[])&#123; char str[9]; int ch,count,i; FILE *fp; if(argc!=2) &#123; printf("Error format,Usage: dumpf filename\n"); return; &#125; if((fp=fopen(argv[1],"r"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; count=0; do&#123; i=0; //按八进制输出第一列，作为一行八个字节的首地址 printf("%06o: ",count*8); do&#123; // 从打开的文件中读取一个字符 ch=fgetc(fp); // 按十进制方式输出这个字符的ASCII码 printf("%4d",ch); // 如果是不可示字符就用"#"字符代替 if(ch&lt;' '||ch&gt;'~') str[i]='#'; // 如果是可示字符，就将它存入数组str以便形成字符串 else str[i]=ch; // 保证每一行输出八个字符 if(++i==8) break; &#125;while(ch!=EOF); // 遇到文件尾标志，结束读文件操作 str[i]='\0'; // 在数组str加字符串结束标志 for(;i&lt;8;i++) printf(" "); // 一行不足八个字符用空格填充 printf(" %s\n",str); // 输出字符串 count++; // 准备输出下一行 &#125;while(ch!=EOF); // 直到文件结束 fclose(fp); // 关闭fp所指文件&#125; 从文件中读取一个字符串函数原型1char *fgets(char *str,int n,FILE *fp) 功能说明从由 fp 指出的文件中读取 n-1 个字符，并把它们存放到由 str 指出的字符数组中去，最后加上一个字符串结束符 &#39;\0&#39; 。 参数说明str：接收字符串的内存地址，可以是数组名，也可以是指针。n： 指出要读取字符的个数。fp：这是个文件指针，指出要从中读取字符的文件。 返回值正常返回：返回字符串的内存首地址，即 str 的值。非正常返回：返回一个 NULL 值，此时应当用 feof() 或 ferror() 函数来判别是读取到了文件尾，还是发生了错误。例如，要从”写打开”文件中读取字符串，将发生错误而返回一个 NULL 值。 写一个字符串到文件中去函数原型1int fputs(char *str,FILE *fp) 功能说明把由 str 指出的字符串写入到 fp 所指的文件中去。 参数说明str：指出要写到文件中去的字符串。fp：这是个文件指针，指出字符串要写入其中的文件。 返回值正常返回： 写入文件的字符个数，即字符串的长度。非正常返回：返回一个 NULL 值，此时应当用 feof() 或 ferror() 函数来判别是读取到了文件尾，还是发生了错误。例如，要往一个”读打开” 文件中写字符串时，会发生错误而返回一个 NULL 值。 实例以下程序将一个文件的内容附加到另一个文件中去： 1234567891011121314151617181920212223242526272829303132333435363738394041//程序名：linkfile.c//执行时可用：linkfile filename1 filename2形式的命令行运行，将文件filename2的内容附加在文件filename1之后。// file linked program.#include &lt;stdio.h&gt;#define SIZE 512void main(int argc,char *argv[])&#123; char buffer[SIZE]; FILE *fp1,*fp2; if(argc!=3) &#123; printf("Usage: linkfile filename1 filename2\n"); return; &#125; // 按追加方式打开argv[1] 所指文件 if((fp1=fopen(argv[1],"a"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; if((fp2=fopen(argv[2],"r"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[2]); return; &#125; // 读入一行立即写出，直到文件结束 while(fgets(buffer,SIZE,fp1)!=NULL) printf("%s\n",buffer); while(fgets(buffer,SIZE,fp2)!=NULL) fputs(buffer,fp1); fclose(fp1); fclose(fp2); if((fp1=fopen(argv[1],"r"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; while(fgets(buffer,SIZE,fp1)!=NULL) printf("%s\n",buffer); fclose(fp1);&#125; 往文件中写格式化数据函数原型1int fprintf(FILE *fp,char *format,arg_list) 功能说明将变量表列（arg_list）中的数据，按照 format 指出的格式，写入由 fp 指定的文件。fprintf() 函数与 printf() 函数的功能相同，只是 printf() 函数是将数据写入屏幕文件（stdout）。 参数说明fp：这是个文件指针，指出要将数据写入的文件。format：这是个指向字符串的字符指针，字符串中含有要写出数据的格式，所以该字符串成为格式串。格式串描述的规则与 printf() 函数中的格式串相同。arg_list：是要写入文件的变量表列，各变量之间用逗号分隔。 返回值无。 实例下列程序的执行文件为 display.exe ，执行时键入命令行： 1display [-i][-s] filename 下面的表格列出了命令行参数的含义及其功能： 12345678910111213141516171819202122232425262728//存储文件名：save.txt//程序代码如下：// file display program.#include &lt;stdio.h&gt;void main()&#123; char name[10]; int nAge,nClass; long number; FILE *fp; if((fp=fopen("student.txt","w"))==NULL) &#123; printf("The file %s can not be opened.\n","student.txt"); return; &#125; fscanf(stdin,"%s %d %d %ld",name,&amp;nClass,&amp;nAge,&amp;number); fprintf(fp,"%s %5d %4d %8ld",name,nClass,nAge,number); fclose(fp); if((fp=fopen("student.txt","r"))==NULL) &#123; printf("The file %s can not be opened.\n","student.txt"); return; &#125; fscanf(fp,"%s %d %d %ld",name,&amp;nClass,&amp;nAge,&amp;number); printf("name nClass nAge number\n"); fprintf(stdout,"%-10s%-8d%-6d%-8ld\n",name,nClass,nAge,number); fclose(fp);&#125; 以二进制形式读取文件中的数据函数原型1int fread(void *buffer,unsigned sife,unsigned count,FILE *fp) 功能说明从由 fp 指定的文件中，按二进制形式将 sife*count 个数据读到由 buffer 指出的数据区中。 参数说明buffer：这是一个 void 型指针，指出要将读入数据存放在其中的存储区首地址。sife：指出一个数据块的字节数，即一个数据块的大小尺寸。count：指出一次读入多少个数据块（sife）。fp：这是个文件指针，指出要从其中读出数据的文件。 返回值正常返回：实际读取数据块的个数，即 count 。异常返回：如果文件中剩下的数据块个数少于参数中 count 指出的个数，或者发生了错误，返回0值。此时可以用 feof() 和 ferror() 来判定到底出现了什么情况。 以二进制形式写数据到文件中去函数原型1int fwrite(void *buffer,unsigned sife,unsigned count,FILE *fp) 功能说明按二进制形式，将由 buffer 指定的数据缓冲区内的 sife*count 个数据写入由 fp 指定的文件中去。 参数说明buffer：这是一个 void 型指针，指出要将其中数据输出到文件的缓冲区首地址。sife：指出一个数据块的字节数，即一个数据块的大小尺寸。count：一次输出多少个数据块（sife）。fp：这是个文件指针，指出要从其中读出数据的文件。 返回值正常返回：实际输出数据块的个数，即 count 。异常返回：返回0值，表示输出结束或发生了错误。 实例123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#define SIZE 4struct worker&#123; int number; char name[20]; int age;&#125;;void main()&#123; struct worker wk; int n; FILE *in,*out; if((in=fopen("file1.txt","rb"))==NULL) &#123; printf("The file %s can not be opened.\n","file1.txt"); return; &#125; if((out=fopen("file2.txt","wb"))==NULL) &#123; printf("The file %s can not be opened.\n","file2.txt"); return; &#125; while(fread(&amp;wk,sizeof(struct worker),1,in)==1) fwrite(&amp;wk,sizeof(struct worker),1,out); fclose(in); fclose(out);&#125; 以二进制形式读取一个整数函数原型1int getw(FILE *fp) 功能说明从由 fp 指定的文件中，以二进制形式读取一个整数。 参数说明fp：是文件指针。 返回值正常返回：所读取整数的值。异常返回：返回 EOF ，即 -1 。由于读取的整数值有可能是 -1 ，所以必须用 feof() 或 ferror() 来判断是到了文件结束，还是出现了一个出错。 实例12345678910111213141516171819#include &lt;stdio.h&gt;void main(int argc,char *argv[])&#123; int i,sum=0; FILE *fp; if(argc!=2) &#123; printf("Command error,Usage: readfile filename\n"); exit(1); &#125; if(!(fp=fopen(argv[1],"rb"))) &#123; printf("The file %s can not be opened.\n",argv[1]); exit(1); &#125; for(i=1;i&lt;=10;i++) sum+=getw(fp); printf("The sum is %d\n",sum); fclose(fp);&#125; 以二进制形式存贮一个整数函数原型1int putw(int n,FILE *fp) 功能说明以二进制形式把由变量 n 指出的整数值存放到由 fp 指定的文件中。 参数说明n：要存入文件的整数。fp：是文件指针。 返回值正常返回：所输出的整数值。异常返回：返回 EOF ，即 -1 。由于输出的整数值有可能是 -1，所以必须用 feof() 或 ferror() 来判断是到了文件结束，还是出现了一个出错。 实例12345678910111213141516171819#include &lt;stdio.h&gt;void main(int argc,char *argv[])&#123; int i; FILE *fp; if(argc!=2) &#123; printf("Command error,Usage: writefile filename\n"); return; &#125; if(!(fp=fopen(argv[1],"wb"))) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; for(i=1;i&lt;=10;i++) printf("%d\n", putw(i,fp)); fclose(fp);&#125; 文件状态检查文件结束函数原型1int feof(FILE *fp) 功能说明该函数用来判断文件是否结束。 参数说明fp：文件指针。 返回值0：假值，表示文件未结束。1：真值，表示文件结束。 实例1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;void main(int argc,char *argv[])&#123; FILE *in,*out; char ch; if(argc!=3) &#123; printf("Usage: copyfile filename1 filename2\n"); return; &#125; if((in=fopen(argv[1],"rb"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; if((out=fopen(argv[2],"wb"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[2]); return; &#125; while(!feof(in)) &#123; ch=fgetc(in); if(ferror(in)) &#123; printf("read error!\n"); clearerr(in); &#125; else &#123; fputc(ch,out); if(ferror(out)) &#123; printf("write error!\n"); clearerr(out); &#125; &#125; &#125; fclose(in); fclose(out);&#125; 文件读/写出错函数原型1int ferror(FILE *fp) 功能说明检查由 fp 指定的文件在读写时是否出错。 参数说明fp：文件指针。 返回值0：假值，表示无错误。1：真值，表示出错。 清除文件错误标志函数原型1void clearerr(FILE *fp) 功能说明清除由 fp 指定文件的错误标志。 参数说明fp：文件指针。 返回值无。 实例1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;void main(int argc,char *argv[])&#123; FILE *in,*out; char ch; if(argc!=3) &#123; printf("Usage: copyfile filename1 filename2\n"); return; &#125; if((in=fopen(argv[1],"rb"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; if((out=fopen(argv[2],"wb"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[2]); return; &#125; while(!feof(in)) &#123; ch=fgetc(in); if(ferror(in)) &#123; printf("read error!\n"); clearerr(in); &#125; else &#123; fputc(ch,out); if(ferror(out)) &#123; printf("write error!\n"); clearerr(out); &#125; &#125; &#125; fclose(in); fclose(out);&#125; 了解文件指针的当前位置函数原型1long ftell(FILE *fp) 功能说明取得由 fp 指定文件的当前读/写位置，该位置值用相对于文件开头的位移量来表示。 参数说明fp：文件指针。 返回值正常返回：位移量（这是个长整数）。异常返回：-1，表示出错。 文件定位反绕函数原型1void rewind(FILE *fp) 功能说明使由文件指针 fp 指定的文件的位置指针重新指向文件的开头位置。 参数说明fp：文件指针。 返回值无。 实例123456789101112#include &lt;stdio.h&gt;void main()&#123; FILE *in,*out; in=fopen("filename1","r"); out=fopen("filename2","w"); while(!feof(in)) fputc(fgetc(in),out); rewind(out); while(!feof(in)) putchar(fgetc(in)); fclose(in); fclose(out);&#125; 随机定位函数原型1int fseek(FILE *fp,long offset,int base) 功能说明使文件指针 fp 移到基于 base 的相对位置 offset 处。 参数说明fp：文件指针。offset：相对 base 的字节位移量。这是个长整数，用以支持大于 64KB 的文件。base：文件位置指针移动的基准位置，是计算文件位置指针位移的基点。ANSI C 定义了base的可能取值，以及这些取值的符号常量。 返回值正常返回：当前指针位置。异常返回：-1，表示定位操作出错。 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct std_type&#123; int num; char name[20]; int age; char class;&#125;stud;int cstufile()&#123; int i; FILE *fp; if((fp=fopen("stufile","wb"))==NULL) &#123; printf("The file can't be opened for write.\n"); return 0; &#125; for(i=1;i&lt;=100;i++) &#123; stud.num=i; strcpy(stud.name,"aaaa"); stud.age=17; stud.class='8'; fwrite(&amp;stud,sizeof(struct std_type),1,fp); &#125; fclose(fp); return 1;&#125;void main()&#123; int n; FILE *fp; if(cstufile()==0) return; if((fp=fopen("stufile","rb"))==NULL) &#123; printf("The file can not be opened.\n"); return; &#125; for(n=0;n&lt;100;n+=2) &#123; fseek(fp,n*sizeof(struct std_type),SEEK_SET); fread(&amp;stud,sizeof(struct std_type),1,fp); printf("%10d%20s%10d%4c\n",stud.num,stud.name,stud.age,stud.class); &#125; fclose(fp);&#125; 关于exit()函数函数原型1void exit(int status) 功能说明exit() 函数使程序立即终止执行，同时将缓冲区中剩余的数据输出并关闭所有已经打开的文件。 参数说明status：为0值表示程序正常终止，为非0值表示一个定义错误。 返回值无。 关于feof()函数函数原型1int feof(FILE *fp) 功能说明在文本文件（ASCII文件）中可以用值为 -1 的符号常量 EOF 来作为文件的结束符。但是在二进制文件中 -1 往往可能是一个有意义的数据，因此不能用它来作为文件的结束标志。为了能有效判别文件是否结束，ANSI C 提供了标准函数 feof() ，用来识别文件是否结束。 参数说明fp：文件指针。 返回值返回为非0值：已到文件尾。返回为0值：表示还未到文件尾。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超五类和六类网线的区别]]></title>
    <url>%2F2019%2F05%2F17%2F%E8%B6%85%E4%BA%94%E7%B1%BB%E5%92%8C%E5%85%AD%E7%B1%BB%E7%BD%91%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[网线，电脑网络组成的最不起眼的部分，最容易被忽视的部件。在组建网络时，人们大多会重视如交换机、路由器、网卡等设备，但对于网线，一般不会太多的去挑剔。但随着网络规模的扩大，对网线需求的增加，网线的重要性越来越明显。下面一起来了解下网线基本知识，告诉你什么样的网线好，超五类和六类网线区别。 了解网线小常识-网线的种类双绞线（Twisted Pair）网线的种类双绞线（twisted pair，TP）是一种综合布线工程中最常用的传输介质，一般由两根22～26号绝缘铜导线相互缠绕而成，双绞线的名字也是由此而来。它的特点就是价格便宜，所以被广泛应用，如我们常见的电话线等。它是用来和RJ45水晶头相连的。 双绞线可分为非屏蔽双绞线（UTP）和屏蔽双绞线（STP）： 屏蔽双绞线电缆的外层由铝铂包裹，以减小辐射，但并不能完全消除辐射，屏蔽双绞线价格相对较高，安装时要比非屏蔽双绞线电缆困难。 非屏蔽双绞线电缆具有以下优点：无屏蔽外套，直径小，节省所占用的空间；重量轻，易弯曲，易安装；将近端串扰减至最小或加以消除；具有阻燃性；具有独立性和灵活性，适用于结构化综合布线。 双绞线常见的型号一类线（CAT1）：主要用于传输语音（一类标准主要用于八十年代初之前的电话线缆），不同于数据传输。 二类线（CAT2）：传输频率为1MHZ，用于语音传输和最高传输速率4Mbps的数据传输，常见于使用4MBPS规范令牌传递协议的旧的令牌网。 三类线（CAT3）：传输频率16MHz，用于语音传输及最高传输速率为10Mbps的数据传输主要用于10BASE–T，在ANSI和EIA/TIA568标准中指定的电缆。 四类线（CAT4）：传输频率为20MHz，用于语音传输和最高传输速率16Mbps的数据传输主要用于基于令牌的局域网和10BASE-T/100BASE-T。 五类线（CAT5）：传输频率为100MHz，用于语音传输和最高传输速率为100Mbps的数据传输，主要用于100BASE-T和10BASE-T网络。这是最常用的以太网电缆，该类电缆增加了绕线密度，外套一种高质量的绝缘材料。 超五类线（CAT5e）：传输频率为100MHz，主要用于千兆位以太网（1000Mbps）。具有衰减小，串扰少，并且具有更高的衰减与串扰的比值（ACR)和信噪比（StructuralReturn Loss)、更小的时延误差，性能得到很大提高。 六类线（CAT6）：传输频率为250MHz，最适用于传输速率高于1Gbps的应用，主要用于千兆位以太网（1000Mbps）。六类双绞线在外形上和结构上与五类或超五类双绞线都有一定的差别，不仅增加了绝缘的十字骨架，将双绞线的四对线分别置于十字骨架的四个凹槽内，而且电缆的直径也更粗。 超六类或6A（CAT6A）：传输频率是200～250 MHz，最大传输速度也可达到1000 Mbps，主要应用于千兆位网络中。超六类线是六类线的改进版，同样是ANSI/EIA/TIA-568B.2和ISO 6类/E级标准中规定的一种非屏蔽双绞线电缆，在串扰、衰减和信噪比等方面有较大改善。 七类线（CAT7）：传输频率至少可达500 MHz，传输速率可达10 Gbps，它主要为了适应万兆位以太网技术的应用和发展。该线是ISO 7类/F级标准中最新的一种屏蔽双绞线。 超五类和六类网线区别超五类和六类网线连接使用并无不同，只是使用的场合和成本不一样。 超五类线的标识是“CAT5E”，带宽155M，是目前的主流产品； 六类线的标识是“ CAT6”，带宽250M，六类非屏蔽双绞线可以非常好地支持千兆以太网，并实现100m的传输距离。六类布线系统被广泛应用子服务器机房的布线，以及保留升级至千兆以太网能力的水平布线。六类非屏蔽双绞线虽然价格较高，但由于与超五类布线系统具有非常好的兼容性，且能够非常好地支持1000Base-T，所以正慢慢成为综合布线的新宠。 若考虑网络将来的应用需求，理论上应安装最先进的布线产品，因为安装电缆后往往难以重新更新替代，基本上，一个布线系统至少要应用10年作为标准，能够支持4至5代的网络设备的性能更新，如果将来的网络设备需要更好的电缆才能提高数据速度。那么，用六类电缆代替超五类电缆是无可避免的，但这些电缆重新组建工程非常昂贵，所以纵使六类产品的价格相对于超五类产品稍贵，但为了减少日后网络升级问题，六类产品仍然值得考虑。 同轴电缆（Coaxial Cable）网线的种类同轴电缆(Coaxial Cable)是指有两个同心导体，而导体和屏蔽层又共用同一轴心的电缆。最常见的同轴电缆由绝缘材料隔离的铜线导体组成，在里层绝缘材料的外部是另一层环形导体及其绝缘体，然后整个电缆由聚氯乙烯或特氟纶材料的护套包住。 光缆（Optical Fiber Cable）网线的种类光缆(optical fiber cable)是为了满足光学、机械或环境的性能规范而制造的，它是利用置于包覆护套中的一根或多根光纤作为传输媒质并可以单独或成组使用的通信线缆组件。光缆是一定数量的光纤按照一定方式组成缆心，外包有护套，有的还包覆外护层，用以实现光信号传输的一种通信线路。 掌握网络选购方法 确保上网质量网线材质哪种好 铜包铁线此类网线在铁线外面电镀了一层铜，因为趋肤效应，对铁线的导电能力有一定提升，电阻较大，不适合POE供电。 铁芯线铁芯线此类网线电阻较大，不适合POE供电，仅适合短距离内传输且对网速要求不高的情况下使用。 混合性线材混合性线材里面部分线使用铜，部分线使用铝，仅适合短距离使用，可用于POE供电，水晶头接法严格。 网线哪种好 网线选购方法 交换机和猫的区别 交换机和路由器的区别家庭网络与办公网络区别家庭中大多使用双绞线(即一般的网线)，一般分为T568A和T568B两种线序，信息模块端接入方式分T568A模块和T568B模块两种方式，两种端接方式所对应的接线顺序如下： T586A模式 ：白绿 、绿 、白橙 、蓝 、白蓝 、橙 、白棕 、棕 T586B模式 ：白橙 、橙 、白绿 、蓝 、白蓝 、绿 、白棕 、棕 家庭网线布线建议在进行网络布线前，首先应该了解自己的居室环境及各房间的用途，什么地方可以开槽埋线，什么地方不可以？同时要了解家庭的网络需求，什么地方要上网？什么地方要看电视？自己心里要有数。 根据自己的设想来画出设计草图，然后根据房间的电源配电箱、有线电视进线口和电话线、网线入户口的位置，确定配电箱及分线器的位置。一般配电箱不要轻易移动；电话线及网络线的配线箱应选一个既不影响美观又方便操作的地方，考虑到要放路由器和交换机，所以应设计一个较大的配线箱；有线电视则在进线口设计一个能摆放两只电视分配器的盒子。 建议大家采用的是并联布线方式，并且电话线和网线分别采用4芯和8芯（五类线）线，为了方便，电话线和网络线穿在同一根PVC管内（理论上电话线和网络线应分开布线，间距10cm以避免相互干扰），考虑到家庭电话和网络同时使用的时间很短，不会造成大的干扰。假如有多台电脑要同时上网时，只要在总配线处加一个宽带路由器或交换机即可。 办公室网络布线建议综合性：办公室布线需要满足各种不同模拟或数字信号的传输需求，将所有的语言、数据、图象、监控设备的布线组合在一套标准的布线系统上，设备与信息出口之间只需一根标准的连接线通过标准的接口把它们接通即可。 可靠性：办公室布线系统使用的产品必须要通过国际组织认证，布线系统的设计、安装、测试以ANSI EIA/TIA 568A及GB/T50311-200为布线标准、遵循国内的布线规范和测试规范。 灵活性：每个办公地点到底使用多少个信息点，办公室布线不仅满足用户当前需求，也要符合用户对未来信息系统统的期望；而且数据、语音双绞线布线应具有可换性，构成一套完整的布线系统。 合理性：办公室强弱电的布线走向要合理搭配，互不干扰，而且要外形美观；用户同时使用计算机的电源、电话、网线要方便操作、便于以后的运行维护。 有线和无线的互补性：根据大楼的具体建筑环境和办公要求，长期还是临时使用网络等情况下，决定采用有线的布线还是无线；一般来说，是将有线和无线结合起来，发挥各自的特长，来达到我们上网办公的目的。 网线插座接法用剥线工具或压线钳的刀具在离线头10厘米长左右将双绞线的外包皮剥去，露出四对双绞线。开始打线，先不要拆开各线对，在将相应线对预先压入打线柱时才拆开。 按照信息模块上所指示的色标选择我们偏好的线序模式(在一个布线系统中最好只统一采用一种线序模式，否则接乱了，网络不通则很难查)。将全部的线都压进各槽位后，用工具压住模块和线，用力压下去，将线卡在模块里面，并把多余的先头剪掉。就是将打好线的信息模块装到86盒面板上，这样墙壁网线插座就安装好了。 网线和电话线的区别 网线和电话线共用网线和电话线的区别作用不同 电话线通过ADSL，将电脑的数字信号调制成模拟线号通过电话线传播，到对端就是电信那边以后，再把模拟信号解调成数字信号。网线上网则少了调制解调这一步。 带宽问题。电话线受物理带宽影响，一般带宽不会太高（最大宽带值为8M），网线物理带宽比较高（好的网线可以达到1000M甚至更多） 接口不同为什么用猫连接的都是电话接口，而网线接口连上去都没什么反应的，这是因为从电话线过来的信号，要经过猫的转换和处理才能转发给网络设备，比如转发给电脑、路由器、集线器和交换机等。如果直接接上去的话那么就是无法识别的模拟信号，相当于无信号。 换言之，猫在中间起到的作用，就是信号的转换和简单的处理，具体说就是将电话线过来的模拟信号转换成数字信号交给网络设备，将网络设备发送的数字信号转换为模拟信号通过电话线发出去。 网线和电话线共用好吗选择网线和电话线共用一根网线的方法在中小企业尤其是小型企业的网络系统中常见。一些网络管理者出于为企业节约综合布线的资金的考虑，在电话和网络方面做了中和，选择网线和电话线共用一根网线的方法作为现行状况的解决方案。 为避免后期管理以及维护及排除故障考虑，不建议电话和网络公用一根网线。 网络常见故障分析及处理线路故障线路故障最常见的情况就是线路不通，诊断这种故障可用ping检查线路远端的路由器端口是否还能响应，或检测该线路上的流量是否还存在。一旦发现远端路由器端口不通，或该线路没有流量，则该线路可能出现了故障。 这时有几种处理方法。 首先是ping线路两端路由器端口，检查两端的端口是否关闭了。如果其中一端端口没有响应则可能是路由器端口故障。如果是近端端口关闭，则可检查端口插头是否松动，路由器端口是否处于down的状态；如果是远端端口关闭，则要通知线路对方进行检查。进行这些故障处理之后，线路往往就通畅了。 如果线路仍然不通，一种可能就得线路本身的问题，看是否线路中间被切断；另一种可能就是路由器配置出错，比如路由循环了。就是远端端口路由又指向了线路的近端，这样线路远端连接的网络用户就不通了，这种故障可以用traceroute来诊断。解决路由循环的方法就是重新配置路由器端口的静态路由或动态路由。 路由器故障事实上，线路故障中很多情况都涉及到路由器，因此也可以把一些线路故障归结为路由器故障。 但线路涉及到两端的路由器，因此在考虑线路故障是要涉及到多个路由器。有些路由器故障仅仅涉及到它本身，这些故障比较典型的就是路由器CPU温度过高、CPU利用率过高和路由器内存余量太小。其中最危险的是路由器CPU温度过高，因为这可能导致路由器烧毁。而路由器CPU利用率过高和路由器内存余量太小都将直接影响到网络服务的质量，比如路由器上丢包率就会随内存余量的下降而上升。 检测这种类型的故障，需要利用MIB变量浏览器这种工具，从路由器MIB变量中读出有关的数据，通常情况下网络管理系统有专门的管理进程不断地检测路由器的关键数据，并及时给出报警。而解决这种故障，只有对路由器进行升级、扩内存等，或者重新规划网络的拓扑结构。 另一种路由器故障就是自身的配置错误。比如配置的协议类型不对，配置的端口不对等。这种故障比较少见，在使用初期配置好路由器基本上就不会出现了。 主机故障主机故障常见的现象就是主机的配置不当。比如，主机配置的IP地址与其他主机冲突，或IP地址根本就不在子网范围内，这将导致该主机不能连通。 如某网段范围是172.17.14.1—172.17.14.253，所以主机地址只有设置在此段区间内才有效。还有一些服务设置的故障。比如E-Mail服务器设置不当导致不能收发E-Mail，或者域名服务器设置不当将导致不能解析域名。 主机故障的另一种可能是主机安全故障。比如，主机没有控制其上的finger，rpc，rlogin等多余服务。而恶意攻击者可以通过这些多余进程的正常服务或bug攻击该主机，甚至得到该主机的超级用户权限等。 主机的其他故障比如不当共享本机硬盘等，将导致恶意攻击者非法利用该主机的资源。发现主机故障是一件困难的事情，特别是别人恶意的攻击。一般可以通过监视主机的流量、或扫描主机端口和服务来防止可能的漏洞。 当发现主机受到攻击之后，应立即分析可能的漏洞，并加以预防，同时通知网络管理人员注意。现在，各市都安装了防火墙，如果防火墙地址权限设置不当，也会造成网络的连接故障，只要在设置使用防火墙时加以注意，这种故障就能解决。 最好的网线 网线哪个牌子好]]></content>
      <categories>
        <category>网线</category>
      </categories>
      <tags>
        <tag>网线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu远程ssh使用root账户登录时的权限问题]]></title>
    <url>%2F2019%2F05%2F05%2FUbuntu%E8%BF%9C%E7%A8%8Bssh%E4%BD%BF%E7%94%A8root%E8%B4%A6%E6%88%B7%E7%99%BB%E5%BD%95%E6%97%B6%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Ubuntu使用ssh进行远程登陆，账户为 root 时，提示出现 Permission denied 错误。 解决办法，编辑服务器中的 /etc/ssh/sshd_config 配置文件： 搜索找到 PermitRootLogin without-password 这行，注释掉，然后添加代码 PermitRootLogin yes 然后重启 ssh 1sudo service ssh restart 另外，用 ssh密钥也可以，使用 ssh-keygen 生成后，追加在 /root/.ssh/authorized_keys 文件中即可.]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu,ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何防止QQ轻聊版强制升级TIM]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2QQ%E8%BD%BB%E8%81%8A%E7%89%88%E5%BC%BA%E5%88%B6%E5%8D%87%E7%BA%A7TIM%2F</url>
    <content type="text"><![CDATA[QQ主要使用以下2个升级程序来自动升级： txupd.exeQQProtectUpd.exebugreport.exe 点击 Win 键，键盘输入 gpedit.msc, 回车，定位到 用户配置 - 管理模版 - 系统 - 不要运行特定的Windows 应用 : 双击 不要运行特定的Windows 应用 ， 将其 启用，并且在下面的 列表 中添加上面提到的2个程序名称，然后保存即可。 后续 QQ 将无法启动这两个程序，也就不会弹窗提醒，更不会给你悄悄的升级了。]]></content>
      <categories>
        <category>QQ</category>
      </categories>
      <tags>
        <tag>QQ,TIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10使用Robocopy多线程功能加速中的文件复制]]></title>
    <url>%2F2019%2F04%2F18%2FWindows10%E4%BD%BF%E7%94%A8Robocopy%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%9F%E8%83%BD%E5%8A%A0%E9%80%9F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[当用户需要将文件或文件夹复制到另一个驱动器时，通常都使用（GUI 中）标准的选择、复制和粘贴操作。虽然默认的批量文件复制和移动功能在 Windows 10 操作系统中已经历经过微软多次优化，已经能够工作得很好，但当尝试传输大批量文件（特别是大量小文件）时，还是需要很长时间，速度就成了一个瓶颈。 此时，许多精通技术的 Windows 用户都会使用 Robocopy（Robust File Copy，强大的文件复制），这是一个内置于 Windows 10 中的命令行工具，它提供了更多功能来帮助用户更快地将数据移动到不同的位置。 Robocopy 最为特殊也经常被忽略的是其支持多线程的能力，允许我们同时复制多个文件，而不像在文件管理器中复制文件时只能一次一个（移动多个文件时也只是列队之后一个一个移动）。 下面介绍在 Windows 10 中如何使用 Robocopy 的多线程副本功能来加快文件和文件夹的复制、移动传输过程。 如何使用Robocopy多线程特性如果你要将 Windows 10 中的大量文件和文件夹复制到另一个驱动器，可以仿照如下步骤来实现 Robocopy 多线程功能以达到超快的数据复制速度： 以管理员权限打开「命令提示符」执行类似如下命令进行多线程复制1ROBOCOPY source destination [file [file]...] [options] source : 源目录(驱动器:\路径或\服务器\共享\路径)。destination : 目标目录(驱动器:\路径或\服务器\共享\路径)。file : 要复制的文件(名称/通配符: 默认为 “.“)。 例如： 1robocopy D:\Pictures\ E:\收藏\Pictures /S /ZB /R:5 /W:5 /V /MT:8 注意：请自行将源路径和目标路径替换成你自己的。 Robocopy命令行用法解释robocopy 的功能非常强大，因此其命令行开关也非常之多，下面我们只列出能够可靠、快速复制文件的常用开关。 /S: 复制子目录，但不复制空的子目录。/E: 复制子目录，包括空的子目录。/LEV:n: 仅复制源目录树的前 n 层。/Z: 在可重新启动模式下复制文件。/B: 在备份模式下复制文件。/ZB: 使用可重新启动模式；如果拒绝访问，请使用备份模式。/J: 复制时使用未缓冲的 I/O (推荐在复制大文件时使用)。/R:n: 失败副本的重试次数: 默认为 1 百万。/W:n: 两次重试间的等待时间: 默认为 30 秒。/TBD: 等待定义共享名称(重试错误 67)。/NP: 无进度 – 不显示已复制的百分比。/V: 生成详细输出，同时显示跳过的文件。/MOV: 移动文件(复制后从源中删除)。/MOVE: 移动文件和目录(复制后从源中删除)。/MT:32: 使用 n 个线程进行多线程复制(默认值为 8)。必须至少为 1，但不得大于 128。 上述命令中最为重要的开关就是 /MT，它让 robocopy 能够以多线程模式进行复制传输。如果你没为 /MT设置数字，那么默认数字是 8，这意味着 Robocopy 将会同时复制 8 个文件。我个人推荐使用 8个线程，虽然可开的线程可以更多，但数字越大，所使用的系统资源和带宽就越多。]]></content>
      <categories>
        <category>Windows10</category>
      </categories>
      <tags>
        <tag>Windows10,Robocopy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu UFW 防火墙设置]]></title>
    <url>%2F2019%2F04%2F17%2FUbuntu%20UFW%20%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装Ubuntu 默认是有 ufw 的。如果因为种种原因没有的话：1sudo apt-get install ufw 初步配置1sudo nano /etc/default/ufw 开启 ipv6 (optional)1IPV6=yes 设置默认规则12sudo ufw default deny incomingsudo ufw default allow outgoing 设置 incoming 规则允许 ssh1sudo ufw allow 22/tcp 允许 http、https12sudo ufw allow 80sudo ufw allow 443 允许端口段1sudo ufw allow 1000:2000/tcp 允许 ip1sudo ufw allow from 192.168.1.125 设置允许 ip / subnet 访问特定端口1sudo ufw allow from 192.168.100.0/24 to any port 3306 设置禁止规则修改 allow 为 deny 即可。 开启 UFW1sudo ufw enable 查看 UFW 状态1sudo ufw status [verbose|numbered] 删除规则1sudo ufw delete allow 1000:2000/tcp 或 12sudo ufw status numberedsudo ufw delete [number] [number] 为上一条返回的规则号码 其他关闭 UFW1sudo ufw disable 重设 UFW1sudo ufw reset 开启关闭 Logging1sudo ufw logging [on|off]]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu,UFW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统出现无法连接adb问题的解决方案]]></title>
    <url>%2F2019%2F04%2F12%2FUbuntu%E7%B3%BB%E7%BB%9F%E5%87%BA%E7%8E%B0%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5adb%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[如果以下情况： 1234$ adb devicesList of devices attachedxxxxxxxx no permissions (user in plugdev group; are your udev rules wrong?);see [http://developer.android.com/tools/device.html] 检查设备的ID和产品ID： 123456789$ lsusbBus 001 Device 002: ID 8087:8000 Intel Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 003 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 002 Device 078: ID 138a:0011 Validity Sensors, Inc. VFS5011 Fingerprint ReaderBus 002 Device 003: ID 8087:07dc Intel Corp. Bus 002 Device 002: ID 5986:0652 Acer, Inc Bus 002 Device 081: ID 22b8:2e81 Motorola PCS #示例设备Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 在这里，示例设备为 Motorola PCS ，所以我的 vid=22b8 和 pid=2e81 在路径 /etc/udev/rules.d 下，新建 51-android.rules 12$ sudo vi /etc/udev/rules.d/51-android.rulesSUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;22b8&quot;, ATTR&#123;idProduct&#125;==&quot;2e81&quot;, MODE=&quot;0666&quot;, GROUP=&quot;plugdev&quot; 现在重启 udev 规则 1sudo udevadm control --reload-rules 现在，设备可以被识别了： 123$ adb devicesList of devices attachedZF6222Q9D9 device 如果依然无法识别：1、重新拔插手机设备；2、重启系统。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu,adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Samba文件共享服务端]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%90%AD%E5%BB%BASamba%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Samba 是著名的开源软件项目之一，它在 Linux/UNIX 系统中实现了微软的 SMB/CIFS 网络协议，从而使得跨平台的文件共享变得更加容易。在部署 Windows、Linux/UNIX 混合平台的企业环境时，选用 Samba 可以很好地解决不同系统之间的文件互访问题。 开始准备Windows电脑和服务器主机必须在相同的工作站域下，打开命令提示符检查Windows系统所在的工作站域 1net config workstation 在Windows系统中，修改 hosts 文件，以管理员权限打开命令提示符，并运行以下命令 1notepad C:\Windows\System32\drivers\etc\hosts 例如： 12[...]192.168.0.100 server1.example.com ubuntu 安装 samba 软件包1sudo apt install samba -y 备份samba的配置文件，方便出错的时候恢复初始设置 1sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak 配置编辑 /etc/samba/smb.conf 文件：在 [global] 节点下添加以下键值对： 12workgroup = WORKGROUPsecurity = user 在文件的最末尾添加新的节点：12345678910111213[SambaShare] comment = Ubuntu File Server Share #描述和介绍 path = /srv/samba/share #请添加需要的路径 browsable = yes #能够被 Windows Explorer 浏览文件或文件夹 guest ok = yes #任何用户都可以访问 read only = no #Windows Explorer 拥有读写权限 create mask = 0777 #当文件被创建的时候，被赋予的默认权限 valid users = tom # 指定登录的用户，该项不写，则默认对所有人可见 force user = nobody # 指定的用户可以进行登录，其他用户没有权限登录，nobody不限制 force group = nogroup # 同上，指定用户组 public = yes # 是否对所有登录成功的用户可见 writable = yes # 写权限，目录的权限也要许可 available = yes # 同样是设置共享目录是否可见 创建待共享的文件夹路径，并赋予权限：12sudo mkdir -p /srv/samba/share #如果父文件夹不存在，则创建父文件夹sudo chown nobody:nogroup /srv/samba/share/ 创建Samba用户1sudo smbpasswd -a tom 然后输入密码即可 重启 samba 系统服务让配置生效1sudo systemctl restart smbd.service nmbd.service 设置访问权限再次强调，以上配置，在局域网内所有的访问客户端都被赋予了所有权限，如果需要配置访问权限，请按照以下说明修改： 编辑 /etc/samba/smb.conf 添加以下网络配置： 123# hosts allow = 127.0.0.1 192.168.1.0/24hosts allow = 127.0.0.1 192.168.1.1 192.168.1.2hosts deny = 0.0.0.0/0 #拒绝其他所有人 分享权限： browseable = no ，代表当客户端访问的时候，无法浏览文件或文件夹 users = user1 user2 ，代表仅列出的用户可以访问此分享 可以参考如下配置： 123456[private] comment = Private Share path = /path/to/share/point browseable = no read only = no valid users = user1 user2 user3 # user1 user2和user3 访问私有分享 设置防火墙可以配置防火墙（如 iptables ）来限制访问你的服务器，Samba 使用以下端口 12UDP : 137 和 138TCP : 139 和 445 查看效果在Windows下通过samba访问服务器内容]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Samba,Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu网络配置]]></title>
    <url>%2F2019%2F03%2F15%2FUbuntu%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[以太网接口识别以太网接口的两种方法： 12345678910111213141516171819202122232425justme@justserver:$ ifconfig -aeno1np0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.1.125 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::4ed9:8fff:fe2c:cb98 prefixlen 64 scopeid 0x20&lt;link&gt; ether 4c:d9:8f:2c:cb:98 txqueuelen 1000 (Ethernet) RX packets 24440107 bytes 35187073438 (35.1 GB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 11198489 bytes 800420673 (800.4 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0eno2np1: flags=4098&lt;BROADCAST,MULTICAST&gt; mtu 1500 ether 4c:d9:8f:2c:cb:99 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 7094 bytes 793776 (793.7 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 7094 bytes 793776 (793.7 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 123456789101112131415161718192021222324252627282930313233justme@justserver:~/AndroidSource/lineage_17.0$ sudo lshw -class network[sudo] password for justme: *-network:0 description: Ethernet interface product: BCM57416 NetXtreme-E Dual-Media 10G RDMA Ethernet Controller vendor: Broadcom Inc. and subsidiaries physical id: 0 bus info: pci@0000:18:00.0 logical name: eno1np0 version: 01 serial: 4c:d9:8f:2c:cb:98 size: 1Gbit/s capacity: 10Gbit/s width: 64 bits clock: 33MHz capabilities: pm vpd msi msix pciexpress bus_master cap_list rom ethernet physical tp 1000bt-fd 10000bt-fd autonegotiation configuration: autonegotiation=on broadcast=yes driver=bnxt_en driverversion=1.10.0 duplex=full firmware=214.0.222.1/pkg 21.40.22.21 ip=192.168.1.125 latency=0 link=yes multicast=yes port=twisted pair speed=1Gbit/s resources: irq:72 memory:9da10000-9da1ffff memory:9d900000-9d9fffff memory:9da22000-9da23fff memory:9de00000-9de7ffff *-network:1 DISABLED description: Ethernet interface product: BCM57416 NetXtreme-E Dual-Media 10G RDMA Ethernet Controller vendor: Broadcom Inc. and subsidiaries physical id: 0.1 bus info: pci@0000:18:00.1 logical name: eno2np1 version: 01 serial: 4c:d9:8f:2c:cb:99 capacity: 10Gbit/s width: 64 bits clock: 33MHz capabilities: pm vpd msi msix pciexpress bus_master cap_list rom ethernet physical tp 1000bt-fd 10000bt-fd autonegotiation configuration: autonegotiation=on broadcast=yes driver=bnxt_en driverversion=1.10.0 duplex=half firmware=214.0.222.1/pkg 21.40.22.21 latency=0 link=no multicast=yes port=twisted pair resources: irq:81 memory:9da00000-9da0ffff memory:9d800000-9d8fffff memory:9da20000-9da21fff memory:9de80000-9defffff 以太网接口逻辑名称接口逻辑名称也可以通过 netplan 配置进行配置。如果要控制哪个接口收到特定的逻辑名称，请使用 match 和 set-name 键。match 键用于根据某些条件（例如MAC地址，驱动程序等）查找适配器。然后，set-name 键可用于将设备更改为所需的逻辑名称。 123456789network: version: 2 renderer: networkd ethernets: eth_lan0: dhcp4: true match: macaddress: 00:11:22:33:44:55 set-name: eth_lan0 以太网接口设置ethtool 是一个程序，用于显示和更改以太网卡设置，例如自动协商，端口速度，双工模式和局域网唤醒。以下是如何查看以太网接口的受支持功能和配置设置： 12345678910111213141516171819202122sudo ethtool eth4Settings for eth4: Supported ports: [ FIBRE ] Supported link modes: 10000baseT/Full Supported pause frame use: No Supports auto-negotiation: No Supported FEC modes: Not reported Advertised link modes: 10000baseT/Full Advertised pause frame use: No Advertised auto-negotiation: No Advertised FEC modes: Not reported Speed: 10000Mb/s Duplex: Full Port: FIBRE PHYAD: 0 Transceiver: internal Auto-negotiation: off Supports Wake-on: d Wake-on: d Current message level: 0x00000014 (20) link ifdown Link detected: yes IP 地址临时IP地址分配对于临时网络配置，可以使用 ip 命令，该命令在大多数其他 GNU / Linux 操作系统上也可以找到。 ip 命令使您可以配置立即生效的设置，但是这些设置不是永久性的，并且在重启后将丢失。 要临时配置 IP 地址，可以按以下方式使用 ip 命令。修改 IP 地址和子网掩码以符合您的网络要求。 1sudo ip addr add 10.102.66.200/24 dev enp0s25 然后可以使用 ip 来设置链接 up 或 down 12ip link set dev enp0s25 upip link set dev enp0s25 down 要验证 enp0s25 的 IP 地址配置，可以按以下方式使用 ip 命令。 1234567ip address show dev enp0s2510: enp0s25: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 00:16:3e:e2:52:42 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 10.102.66.200/24 brd 10.102.66.255 scope global dynamic eth0 valid_lft 2857sec preferred_lft 2857sec inet6 fe80::216:3eff:fee2:5242/64 scope link valid_lft forever preferred_lft forever6 要配置默认网关，可以按以下方式使用ip命令。修改默认网关地址以符合您的网络要求。 1sudo ip route add default via 10.102.66.1 要验证默认网关配置，可以按以下方式使用 ip 命令。 1234ip route showdefault via 10.102.66.1 dev eth0 proto dhcp src 10.102.66.200 metric 10010.102.66.0/24 dev eth0 proto kernel scope link src 10.102.66.20010.102.66.1 dev eth0 proto dhcp scope link src 10.102.66.200 metric 100 如果您需要 DNS 进行临时网络配置，则可以在文件 /etc/resolv.conf 中添加 DNS 服务器 IP 地址。通常，不建议直接编辑 /etc/resolv.conf ，但这是一个临时且非永久的配置。下例显示了如何在 /etc/resolv.conf 中输入两个 DNS 服务器，应将其更改为适合您网络的服务器。下一节将更详细地描述进行 DNS 客户端配置的正确的持久方法。 12nameserver 8.8.8.8nameserver 8.8.4.4 如果您不再需要此配置，并且希望从接口清除所有 IP 配置，则可以将 ip 命令与 flush 选项一起使用，如下所示。 1ip addr flush eth0 使用 ip 命令刷新IP配置不会清除 /etc/resolv.conf 的内容。您必须手动删除或修改这些条目，或者重新引导，这也将导致 /etc/resolv.conf（它是 /run/systemd/resolve/stub-resolv.conf的符号链接）被重写。 动态IP地址分配（DHCP客户端）要将服务器配置为使用 DHCP 进行动态地址分配，请在文件 /etc/netplan/99_config.yaml 中创建一个 netplan 配置。下面的示例假定您正在配置标识为 enp3s0 的第一个以太网接口。 123456network: version: 2 renderer: networkd ethernets: enp3s0: dhcp4: true 然后可以使用 netplan 命令应用该配置。 1sudo netplan apply 静态IP地址分配要将系统配置为使用静态地址分配，请在文件 /etc/netplan/99_config.yaml 中创建一个 netplan 配置。下面的示例假定您正在配置标识为 eth0 的第一个以太网接口。更改地址，gateway4 和名称服务器值，以满足您的网络要求。 12345678910111213network: version: 2 renderer: networkd ethernets: eno1np0: dhcp4: no dhcp6: no addresses: - 192.168.1.125/24 gateway4: 192.168.1.1 nameservers: search: [] addresses: [192.168.1.1] eno1np0：指定需配置网络接口的名称。 dhcp4：是否打开 IPv4 的 dhcp。 dhcp6：是否打开 IPv6 的 dhcp。 addresses：定义网络接口的静态 IP 地址。 gateway4：指定默认网关的 IPv4 地址。 nameservers：指定域名服务器的 IP 地址。 然后可以使用 netplan 命令应用该配置。 1sudo netplan apply 环回接口系统将环回接口标识为 lo ，其默认 IP 地址为 127.0.0.1。可以使用 ip 命令查看它。 1234567ip address show lo1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 名称解析与 IP 网络相关的名称解析是将 IP 地址映射到主机名的过程，从而更容易识别网络上的资源。下一节将说明如何使用 DNS 和静态主机名记录正确配置系统以进行名称解析。 DNS客户端配置传统上，文件 /etc/resolv.conf 是静态配置文件，很少需要通过 DCHP 客户端挂接进行更改或自动更改。 Systemd-resolved 处理名称服务器配置，并且应该通过 systemd-resolve 命令与之交互。 Netplan 配置systemd-resolved 生成一个名称服务器和域的列表，以放入 /etc/resolv.conf 中，这是一个符号链接： 1/etc/resolv.conf -&gt; ../run/systemd/resolve/stub-resolv.conf 要配置解析器，请将适合您的网络的名称服务器的 IP 地址添加到 netplan 配置文件中。您还可以添加可选的 DNS 后缀搜索列表以匹配您的网络域名。生成的文件可能如下所示： 1234567891011network: version: 2 renderer: networkd ethernets: enp0s25: addresses: - 192.168.0.100/24 gateway4: 192.168.0.1 nameservers: search: [mydomain, otherdomain] addresses: [1.1.1.1, 8.8.8.8, 4.4.4.4] 搜索选项也可以与多个域名一起使用，以便将 DNS 查询按输入顺序附加。例如，您的网络可能有多个子域可供搜索； example.com 的父域，以及两个子域 sales.example.com 和 dev.example.com 。 如果您要搜索多个域，则配置可能如下所示： 1234567891011network: version: 2 renderer: networkd ethernets: enp0s25: addresses: - 192.168.0.100/24 gateway4: 192.168.0.1 nameservers: search: [example.com, sales.example.com, dev.example.com] addresses: [1.1.1.1, 8.8.8.8, 4.4.4.4] 如果尝试对名称为 server1 的主机执行 ping 操作，系统将按照以下顺序自动查询DNS的完全合格域名（FQDN）： server1.example.com server1.sales.example.com server1.dev.example.com 如果找不到匹配项，则 DNS 服务器将提供 notfound 的结果，并且 DNS 查询将失败。 静态主机名静态主机名是本地定义的主机名到 IP 的映射，位于文件 /etc/hosts 中。默认情况下，hosts 文件中的条目将优先于 DNS 。这意味着，如果您的系统尝试解析主机名并且与 /etc/hosts 中的条目匹配，它将不会尝试在 DNS 中查找记录。在某些配置中，尤其是当不需要 Internet 访问时，可以方便地将与有限数量的资源进行通信的服务器设置为使用静态主机名而不是 DNS 。 以下是主机文件的示例，其中已通过简单的主机名，别名及其等效的完全限定域名（FQDN）标识了许多本地服务器。 123456127.0.0.1 localhost127.0.1.1 ubuntu-server10.0.0.11 server1 server1.example.com vpn10.0.0.12 server2 server2.example.com mail10.0.0.13 server3 server3.example.com www10.0.0.14 server4 server4.example.com file 在上面的示例中，请注意，除了它们的专有名称和 FQDN 之外，还为每个服务器指定了别名。 Server1 已映射为名称 vpn ，server2 被称为 mail ，server3 被称为 www ， server4 被称为 file 。 名称服务交换机配置系统选择将主机名解析为 IP 地址的方法的顺序由名称服务交换机（NSS）配置文件 /etc/nsswitch.conf 控制。如上一节所述，通常，在系统 /etc/hosts 文件中定义的静态主机名优先于从 DNS 解析的名称。以下是文件 /etc/nsswitch.conf 中负责主机名查找此顺序的行的示例。 1hosts: files mdns4_minimal [NOTFOUND=return] dns mdns4 files ：首先尝试解析 /etc/hosts 中的静态主机名。 mdns4_minimal ：尝试使用多播 DNS 解析名称。 [NOTFOUND=return] ：意味着前面的 mdns4_minimal 进程未找到的任何响应都应视为权威，并且系统不应尝试继续寻找答案。 dns ：表示旧式单播 DNS 查询。 mdns4 ：表示多播 DNS 查询。 要修改上述名称解析方法的顺序，只需将 hosts：字符串更改为您选择的值即可。例如，如果您更喜欢使用传统的单播 DNS 而不是多播 DNS ，则可以在 /etc/nsswitch.conf 中更改字符串，如下所示。 1hosts: files dns [NOTFOUND=return] mdns4_minimal mdns4 桥接桥接多个接口是一种更高级的配置，但在多种情况下非常有用。一种情况是建立具有多个网络接口的网桥，然后使用防火墙过滤两个网段之间的流量。另一种情况是在具有一个接口的系统上使用网桥，以允许虚拟机直接访问外部网络。以下示例涵盖了后一种情况。 通过编辑 /etc/netplan/ 中的 netplan 配置来配置网桥： 1234567891011network: version: 2 renderer: networkd ethernets: enp3s0: dhcp4: no bridges: br0: dhcp4: yes interfaces: - enp3s0 为您的物理接口和网络输入适当的值。 现在应用配置以启用网桥： 1sudo netplan apply 现在，新的网桥接口应已启动并正在运行。 brctl 提供有关网桥状态的有用信息，控制哪些接口是网桥的一部分，等等。有关更多信息，请参见 man brctl 。 YAML 语言基本语法规则YAML 语言的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。 YAML 基本语法规则如下: 大小写敏感使用缩进表示层级关系缩进时不允许使用Tab键，只允许使用空格。缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 #表示注释，从这个字符一直到行尾，都会被解析器忽略。 根据 Netplan 的描述文件手动创建网络守护程序的配置信息1sudo netplan generate 执行后会使用 /etc/netplan/*.yaml 生成对应网络守护程序的配置信息。例如： 123456789101112$ cat /run/systemd/network/10-netplan-enp0s5.network[Match]Name=enp0s5[Link]RequiredForOnline=no[Network]Address=192.168.100.211/23Gateway=192.168.100.1DNS=8.8.8.8DNS=8.8.4.4 查看当前系统的 DNS Servers1234567891011121314151617181920212223242526272829303132333435363738$ systemd-resolve --statusGlobal DNSSEC NTA: 10.in-addr.arpa 16.172.in-addr.arpa 168.192.in-addr.arpa 17.172.in-addr.arpa 18.172.in-addr.arpa 19.172.in-addr.arpa 20.172.in-addr.arpa 21.172.in-addr.arpa 22.172.in-addr.arpa 23.172.in-addr.arpa 24.172.in-addr.arpa 25.172.in-addr.arpa 26.172.in-addr.arpa 27.172.in-addr.arpa 28.172.in-addr.arpa 29.172.in-addr.arpa 30.172.in-addr.arpa 31.172.in-addr.arpa corp d.f.ip6.arpa home internal intranet lan local private testLink 2 (enp0s5) Current Scopes: DNS LLMNR setting: yesMulticastDNS setting: no DNSSEC setting: no DNSSEC supported: no DNS Servers: 8.8.8.8 8.8.4.4]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu,网络配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中==和equals和hashCode的区别]]></title>
    <url>%2F2019%2F03%2F13%2FJava%E4%B8%AD%3D%3D%E5%92%8Cequals%E5%92%8ChashCode%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java中的数据类型 基本数据类型，也称原始数据类型 byte、short、char、int、long、float、double、boolean 他们之间的比较，应用双等号（==），比较的是他们的值。 引用类型(类、接口、数组) 当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 对象是放在堆中的，栈中存放的是对象的引用（地址）。由此可见“==”是对栈中的值进行比较的。如果要比较堆中对象的内容是否相同，那么就要重写equals方法了。 123456789101112131415161718192021222324252627282930public class Solution &#123; public static void main(String[] args) &#123; int int1 = 12; int int2 = 12; Integer Integer1 = new Integer(12); Integer Integer2 = new Integer(12); Integer Integer3 = new Integer(127); Integer a1 = 127; Integer b1 = 127; Integer a = 128; Integer b = 128; String s1 = "str"; String s2 = "str"; String str1 = new String("str"); String str2 = new String("str"); System.out.println("int1==int2:" + (int1 == int2)); System.out.println("int1==Integer1:" + (int1 == Integer1)); System.out.println("Integer1==Integer2:" + (Integer1 == Integer2)); System.out.println("Integer3==b1:" + (Integer3 == b1)); System.out.println("a1==b1:" + (a1 == b1)); System.out.println("a==b:" + (a == b)); System.out.println("s1==s2:" + (s1 == s2)); System.out.println("s1==str1:" + (s1 == str1)); System.out.println("str1==str2:" + (str1 == str2)); &#125;&#125; 输出： 123456789int1==int2:trueint1==Integer1:true //Integer会自动拆箱为int，所以为trueInteger1==Integer2:false //不同对象，在内存存放地址不同，所以为falseInteger3==b1:false //Integer3指向new的对象地址，b1指向缓存中127地址，地址不同，所以为falsea1==b1:truea==b:falses1==s2:trues1==str1:falsestr1==str2:false Integer b1 = 127；java在编译的时候，被翻译成-&gt;Integer b1 = Integer.valueOf(127)； 123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 对于-128到127之间的数，会进行缓存，Integer b1 = 127时，会将127进行缓存，下次再写Integer i6 = 127时，就会直接从缓存中取，就不会new了。所以 a1==b1:true a==b:false。 Java中的equals方法解析默认情况（没有覆盖equals方法）下equals方法都是调用Object类的equals方法，而Object的equals方法主要用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。下面是Object类中equals方法， 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 定义的equals与==是等效的 要是类中覆盖了equals方法，那么就要根据具体的代码来确定equals方法的作用了，覆盖后一般都是通过对象的内容是否相等来判断对象是否相等。下面是String类对equals进行了重写； 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = count; if (n == anotherString.count) &#123; char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n-- != 0) &#123; if (v1[i++] != v2[j++]) return false; &#125; return true; &#125; &#125; return false;&#125; 即String中equals方法判断相等的步骤是： 若A==B 即是同一个String对象 返回true 若对比对象是String类型则继续，否则返回false 判断A、B长度是否一样，不一样的话返回false 逐个字符比较，若有不相等字符，返回false 这里对equals重新需要注意五点： 自反性：对任意引用值x，x.equals(x)的返回值一定为true。 对称性：对于任何引用值x、y，当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true。 传递性：如果x.equals(y)=true， y.equals(z)=true，则x.equals(z)=true。 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变。 非空性：任何非空的引用值X，x.equals(null)的返回值一定为false。 实现高质量equals方法的诀窍： 使用==符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。 使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。 把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。 对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。 当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。 hashCode方法解析hashCode()方法返回的就是一个数值，从方法的名称上就可以看出，其目的是生成一个hash码。hash码的主要用途就是在对对象进行散列的时候作为key输入，据此很容易推断出，我们需要每个对象的hash码尽可能不同，这样才能保证散列的存取性能。事实上，Object类提供的默认实现确实保证每个对象的hash码不同（在对象的内存地址基础上经过特定算法返回一个hash码）。Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。 哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。初学者可以这样理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。 散列函数、散列算法、哈希函数是一种从任何一种数据中创建小的数字“指纹”的方法。 散列函数将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。 好的散列函数在输入域中很少出现散列冲突。 所有散列函数都有如下一个基本特性： 如果a=b，则h(a) = h(b)。 如果a!=b，则h(a)与h(b)可能得到相同的散列值。 Object 的hashCode方法：返回一个int类型 1public native int hashCode(); hashCode的作用 想要明白，必须要先知道Java中的集合。总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 于是，Java采用了哈希表的原理。 这样一来，当集合要添加新的元素时， 先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 eqauls方法和hashCode方法关系Java对于eqauls方法和hashCode方法是这样规定的： 同一对象上多次调用hashCode()方法，总是返回相同的整型值。 如果a.equals(b)，则一定有a.hashCode() 一定等于 b.hashCode()。 如果!a.equals(b)，则a.hashCode() 不一定等于b.hashCode()。此时如果a.hashCode() 总是不等于 b.hashCode()，会提高hashtables的性能。 a.hashCode()==b.hashCode() 则 a.equals(b)可真可假。 a.hashCode()！= b.hashCode() 则 a.equals(b)为假。 上面结论简记： 如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。 如果两个对象不equals，他们的hashcode有可能相等。 如果两个对象hashcode相等，他们不一定equals。 如果两个对象hashcode不相等，他们一定不equals。 关于这两个方法的重要规范： 若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该相等”。不过请注意：这个只是规范，如果你非要写一个类让equals(Object obj)返回true而hashcode()返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG。 如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashcode可能相同”。 为什么覆盖equals时总要覆盖hashCode一个很常见的错误根源在于没有覆盖hashCode方法。在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。 在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。 如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。 如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。 总结 equals方法用于比较对象的内容是否相等（覆盖以后） hashcode方法只有在集合中用到 当覆盖了equals方法时，比较对象是否相等将通过覆盖后的equals方法进行比较（判断对象的内容是否相等） 将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java,hashcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的next主题个性化教程]]></title>
    <url>%2F2019%2F02%2F15%2FHexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[设置中文修改配置文件(_config.yml) 1language: zh-Hans 酷炫的动态背景打开\themes\NexT\_config.yml，修改以下内容： 123456789101112131415161718# 背景特效以下4项，是NexT主题集成的，只需将 false 改为 true，即可启用# 不用向网上说的，到模板文件里加引用js的脚本，NexT已经集成了，开启即用# Canvas-nest 浮动线条canvas_nest: enable: true onmobile: true # display on mobile or not color: '0,0,255' # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines# three_waves 水波粒子three_waves: false# canvas_lines 这个是一根线连接两个小点，组成的一个随鼠标放大缩小的东西canvas_lines: false# canvas_sphere 这个是一个很多刺组成的一个球canvas_sphere: false 主页文章添加阴影效果打开themes/next/source/css/_custom/custom.styl文件添加： 1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 启用：页面加载过程中顶部的进度条打开\themes\NexT\_config.yml，找到字段 pace，设为true。还可以将pace_theme:的值，改成相应的名字,变更不同样式的加载条。 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记在路径\themes\next\layout\_macro中新建 passage-end-tag.swig 文件，并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV），代码如下：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml)，在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 主页文章添加阴影效果打开\themes\next\source\css\_custom\custom.styl，向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 设置网站的图标Favicon一张（32*32）的ico图标，或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 在文章底部增加版权信息在目录 next/layout/_macro/下添加 my-copyright.swig： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import "my-post-copyright" 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置 如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加： 1234567---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright:--- 这样每次hexo new “你的内容”之后，生成的md文件会自动把copyright:加到里面去 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig，注释或者直接删除以下代码： 1234567891011121314151617&#123;% if theme.footer.powered.enable %&#125; &lt;div class="powered-by"&gt;&#123;# #&#125;&#123;&#123; __('footer.powered', next_url('https://hexo.io', 'Hexo', &#123;class: 'theme-link'&#125;)) &#125;&#125;&#123;# #&#125;&#123;% if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env('version') &#125;&#125;&#123;% endif %&#125;&#123;# #&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered.enable and theme.footer.theme.enable %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class="theme-info"&gt;&#123;# #&#125;&#123;&#123; __('footer.theme') &#125;&#125; – &#123;&#123; next_url('https://theme-next.org', 'NexT.' + theme.scheme, &#123;class: 'theme-link'&#125;) &#125;&#125;&#123;# #&#125;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 添加站内搜索安装hexo-generator-searchdb插件 1npm install hexo-generator-searchdb --save 编辑_config.yml站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑themes/next/_config.yml 主题配置文件，启用本地搜索功能,将local_search:下面的enable:的值，改成true 123# Local searchlocal_search: enable: true 首页不显示全文(只显示预览)打开主题配置文件/themes/next/_config.yml，将auto_excerpt下面的enable:的值，改成true 12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt:enable: truelength: 150 除了这个方法，还有一个更灵活的方法，直接在编辑的文章中添加标记。这样只会显示标记之前的那部份。 添加打赏功能打开themes/next/_config.yml站点配置文件，找到# Reward把wechatpay:和alipay:前面的#号删除。然后将自己的二维码文件wechatpay.jpg、alipay.jpg图片放入themes/next/source/images中即可。 12345# Rewardreward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png Hexo载入动画效果编辑themes/netx/_config.yml找到motion,将enable的值，改成true 123456789101112131415161718# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn #号里都是载入效果，有时间可以自己多试一试！ 美化右侧滚动条打开themes\next\source\css\_custom\custom.styl文件，将下面的代码添加进去。 12345678910111213141516171819202122//设置滚动条的样式//参考https://segmentfault.com/a/1190000003708894::-webkit-scrollbar &#123; width: 5px; height: 5px;&#125;//滚动槽::-webkit-scrollbar-track &#123; background: #eee;&#125;//滚动条滑块::-webkit-scrollbar-thumb &#123; border-radius: 5px; background-color: #ccc;&#125;::-webkit-scrollbar-thumb:hover &#123; background-color: rgb(247, 149, 51);&#125; 优化鼠标选择文字的样式打开themes\next\source\css\_custom\custom.styl文件，将下面的代码添加进去。 12345::selection &#123; background-color: rgb(255, 241, 89); color: #555;&#125; 网页中文乱码解决办法所有配置文件都可以用记事本打开，如果输入中文后网页显示乱码，则需要将该文件另存为utf-8编码文件 即打开后点击左上角 文件—&gt;另存为，然后在弹出的窗口下方有一个 编码 的下拉菜单，点击选择UTF-8选项，然后点击保存，会提示 是否替换，选择 是 即可。以后出现中文乱码问题都这样解决 设置侧边栏头像将头像图片放在主题目录的source/images/目录下，尺寸是正方形即可，然后将照片改名为avatar.jpg，或者其他后缀名的图片。编辑 主题配置文件，找到关键字avatar，删掉前面的#号，值设置成头像的链接地址，比如 1avatar: /images/avatar.jpg 保存后可用hexo s打开本地服务器预览一下效果 修改链接样式在themes\next\source\css\_common\components\post\post.styl在末尾添加如下css样式： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;]]></content>
      <categories>
        <category>next主题</category>
      </categories>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int、char、long各占多少字节数]]></title>
    <url>%2F2018%2F12%2F17%2Fint%E3%80%81char%E3%80%81long%E5%90%84%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[123456789public static void main(String[] args) &#123; System.out.println(Byte.SIZE); System.out.println(Character.SIZE); System.out.println(Short.SIZE); System.out.println(Integer.SIZE); System.out.println(Float.SIZE); System.out.println(Double.SIZE); System.out.println(Long.SIZE);&#125; 输出： 12345678161632326464 type size description byte 1字节 最小值是 -128（-2^7）；最大值是 127（2^7-1） boolean 至少1字节 这种类型只作为一种标志来记录 true/false 情况 short 2字节 最小值是 -32768（-2^15）；最大值是 32767（2^15 - 1） char 2字节 最小值是 \u0000（即为0）；最大值是 \uffff（即为65,535） int 4字节 最小值是 -2,147,483,648（-2^31）；最大值是 2,147,483,647（2^31^ - 1） float 4字节 单精度浮点数字长32位，尾数长度23，指数长度8,指数偏移量127 long 8字节 最小值是 -9,223,372,036,854,775,808（-2^63）；最大值是 9,223,372,036,854,775,807（2^63 -1） double 8字节 双精度浮点数字长64位，尾数长度52，指数长度11，指数偏移量1023 英文字母： 字节数 : 1，编码：GB2312 字节数 : 1，编码：GBK 字节数 : 1，编码：ISO-8859-1 字节数 : 1，编码：UTF-8 中文汉字： 字节数 : 2，编码：GB2312 字节数 : 2，编码：GBK 字节数 : 1，编码：ISO-8859-1 字节数 : 3，编码：UTF-8]]></content>
      <categories>
        <category>基本数据类型</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页版HTML5视频倍速播放方法]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%BD%91%E9%A1%B5%E7%89%88HTML5%E8%A7%86%E9%A2%91%E5%80%8D%E9%80%9F%E6%92%AD%E6%94%BE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[仅支持的浏览器有Chrome 43+、 Firefox 20+、 IE 9+、 Edge 12+等版本。 123document.querySelector('video').defaultPlaybackRate = 2.0;document.querySelector('video').play();document.querySelector('video').playbackRate = 16.0;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5,倍速播放</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int与integer的区别]]></title>
    <url>%2F2018%2F11%2F15%2Fint%E4%B8%8Einteger%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Integer是int的包装类，int则是java的一种基本数据类型 Integer变量必须实例化后才能使用，而int变量不需要 Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 Integer的默认值是null，int的默认值是0 关于Integer和int的比较 由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 123Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） 123Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） 123Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false 123456Integer i = 100;Integer j = 100;System.out.print(i == j); //trueInteger i = 128;Integer j = 128;System.out.print(i == j); //false 对于第4条的原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下： 1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了]]></content>
      <categories>
        <category>基本数据类型</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer、StringBuilder区别]]></title>
    <url>%2F2018%2F10%2F28%2FString%2CStringBuffer%2CStringBuilder%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[可变性String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。 线程安全性String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。 性能每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结： 如果要操作少量的数据用 = String 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 多线程操作字符串缓冲区 下操作大量数据 = StringBuffer]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>string区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio配置]]></title>
    <url>%2F2018%2F10%2F01%2FAndroid%20Studio%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[当我首次使用Android Studio的时候，会采用如下配置，下面的一些配置技巧或许对你有一定的帮助。 显示行号 File | Settings 打开设置 选择 Editor | General | Appearance 勾选 Show line numbers 命名前缀 File | Settings 打开设置 选择 Editor | Code Style | Java 选择 Code Generation 标签 给普通 Field 添加一个 m 前缀，给 Static filed 添加一个 s 前缀 快速导包 File | Settings 打开设置 选择 Editor | General | Auto Import 勾选 Optimize imports on the fly 勾选 Add unambiguous imports on the fly Logcat 颜色 File | Settings 打开设置 选择 Editor | Color &amp; Fonts | Android Logcat 点击 Click on Save As…按钮创建一个新的配色 Scheme 按照下面的表格修改对应的颜色(修改之前需要取消勾选 Use inherited attributes) Logcat级别 颜色 Assert #AA66CC Debug #33B5E5 Error #FF4444 Info #99CC00 Verbose #BBBBBB Warning #FFBB33 取消代码注释中的显示 File | Settings 打开设置 选择 Editor | Code Style | Java | JavaDoc 打开 Other 节点 取消勾选 Generate ““ on empty lines 代码配色 File | Settings 打开设置 选择 Editor | Color &amp; Fonts | Java 点击 Click on Save As…按钮创建一个新的配色 Scheme 展开下方的 Variables 选择 Local variable 设置右侧的 Foreground 颜色 #68B5EE 字体设置 File | Settings 打开设置 选择 Editor | Font 设置右侧的 Font 选择Consolas，Size选择14 文件编码设置 File | Settings 打开设置 选择 Editor | File Encodings 设置右侧的 Global Encoding、Project Encoding、Default encoding for properties files 为 UTF-8 显示快速文档 File | Settings 打开设置 选择 Editor | General 勾选 Show quick documentation on mouse move 设置启动项 File | Settings 打开设置 选择 Appearance &amp; Behavior | System Settings 取消勾选 Reopen last project on startup 和 Confirm application exit 选择 Open project in new window]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android studio,android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈对java多态的理解]]></title>
    <url>%2F2018%2F09%2F28%2F%E8%B0%88%E8%B0%88%E5%AF%B9java%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[运行时多态性是面向对象程序设计代码重用的一个最强大机制，Java多态性的概念也可以被说成“一个接口，多个方法”。Java实现运行时多态性的基础是动态方法调度，它是一种在运行时而不是在编译期调用重载方法的机制。 方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中Java多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 （但是如果强制把超类转换成子类的话，就可以调用子类中新添加而超类没有的方法了。）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用泛型简化findViewById]]></title>
    <url>%2F2018%2F09%2F26%2F%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%AE%80%E5%8C%96findViewById%2F</url>
    <content type="text"><![CDATA[简化findViewById在Android开发中，通过findViewById来引用资源文件的view，但是资源文件的view过多会导致做很多重复性的工作，代码很冗余，开发效率随之下降。为了减少重复书写findViewById的次数，我们可以这么来写。 12345678910public final class ViewUtils &#123; public static &lt;T extends View&gt; T findViewById(Activity activity,int resId)&#123; return (T) activity.findViewById(resId); &#125; public static &lt;T extends View&gt; T findViewById(View view,int resId)&#123; return (T) view.findViewById(resId); &#125;&#125; 通过使用泛型，可以避免了每次都进行类型转换，很大程度的简化了代码，开发效率也随之提升了。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>泛型,引用资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器完全卸载监控教程]]></title>
    <url>%2F2018%2F09%2F17%2F%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD%E7%9B%91%E6%8E%A7%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[阿里云的服务器都自带监控（AliYunDun/阿里云盾/安骑士教程），大家都不想自己的所作所为都被监控着。 SSH连接阿里云服务器1ssh root@[address] 然后输入密码，即可。 在终端中输入下方命令，进行卸载AliYunDun操作12wget http://update.aegis.aliyun.com/download/uninstall.sh &amp;&amp; chmod +x uninstall.sh &amp;&amp; ./uninstall.shwget http://update.aegis.aliyun.com/download/quartz_uninstall.sh &amp;&amp; chmod +x quartz_uninstall.sh &amp;&amp; ./quartz_uninstall.sh 停止agentwatch.service服务（阿里云盾的监控进程）1systemctl stop agentwatch.service 禁止agentwatch.service服务启动1systemctl disable agentwatch.service 回到根目录1cd / 删除agentwatch.service相关服务1find . -name 'agentwatch*' -type d -exec rm -rf &#123;&#125; \; &amp;&amp; find . -name 'agentwatch*' -type f -exec rm -rf &#123;&#125; \; 强行停止aliyun-service服务1pkill aliyun-service 清理所有带aliyun、aegis关键字的文件12345find . -name 'aliyun*' -type d -exec rm -rf &#123;&#125; \;find . -name 'aliyun*' -type f -exec rm -rf &#123;&#125; \;find . -name 'aegis*' -type f -exec rm -rf &#123;&#125; \;find . -name 'aegis*' -type d -exec rm -rf &#123;&#125; \;rm -fr /usr/sbin/aliyun-service /usr/sbin/aliyun_installer 一些未触发关键字，但属于阿里云夹带私货的服务阿里云还偷偷内置了一堆服务，虽然没有注册到系统里且启动，但为了保险起见，还是将它们一并删除的比较好，有关内置服务的详情，参见：阿里云服务删除 可疑服务有以下几个，有5个位于/etc/systemd/system/multi-user.target.wants/目录下，均以“cloud-”打头的五个服务： 1find /etc/systemd/system/ -name 'cloud-*' | xargs rm -rf 还有一个是位于/lib/systemd/system/目录下的“accounts-daemon.service”文件。注意，删除掉这个，你就无法通过阿里云控制台的VNC面板为机器修改ssh密码、查看机器的详细运行状态了，请谨慎决定是否需要删除（不推荐）： 1rm -fr /lib/systemd/system/accounts-daemon.service 将以上组件删除后，阿里云后面板监控中的操作系统监控和进程监控都变为不可用。 禁止所有与阿里云监控相关的IP访问利用阿里云安全组规则屏蔽相关IP进入云服务器，选择网络与安全，点击配置规则，点击添加安全组规则，各个项目照着填，授权对象填以下这些IP（摘自上面那个阿里云的官网），最后一个“描述”填“屏蔽阿里云盾监控”，点“确定”就行了。 140.205.201.0/28,140.205.201.16/29,140.205.201.32/28,140.205.225.192/29,140.205.225.200/30,140.205.225.184/29,140.205.225.183/32,140.205.225.206/32,140.205.225.205/32,140.205.225.195/32,140.205.225.204/32,106.11.224.0/26,106.11.224.64/26,106.11.224.128/26,106.11.224.192/26,106.11.222.64/26,106.11.222.128/26,106.11.222.192/26,106.11.223.0/26,140.205.201.0/24,140.205.225.0/24 同理，阿里云监测IP也要并到这个安全组规则里面来，以下是待屏蔽的IP： 112.124.127.224,112.124.127.44,112.124.127.64,112.124.127.53,120.26.216.168,120.26.64.126,121.43.107.174,121.43.105.176,121.41.117.242,121.40.130.38,121.41.112.148,115.29.112.222,115.28.203.70,42.96.189.63,115.29.113.101,120.27.40.113,115.28.171.22,115.28.189.208,121.42.196.232,115.28.26.13,120.27.47.144,120.27.47.33,112.126.74.55,182.92.148.207,182.92.1.233,112.126.73.56,123.56.138.37,123.57.10.133,112.126.75.174,182.92.157.118,112.126.75.221,182.92.69.212,10.153.174.11,10.153.175.147,10.153.175.146,110.75.0.0/16,42.120.0.0/16 出方向允许全部就ok，反正我们主要防止的是阿里云的IP主动来找我们机器的麻烦。 安全组规则入方向的屏蔽阿里云监测IP添加完成了，我们再逐条添加常用的443、、80、3306等端口放行规则。 机器内部配置防火墙对于Ubuntu系统，可以考虑开启UFW防火墙，只开放ssh登陆端口和攀云屐端口，在系统防火墙里添加如下规则，彻底锁死阿里云的IP主动探测我们的机器。 安装ufw：1apt-get install ufw 开启ufw：1ufw enable 编辑配置文件如果你的机器自带IPv6地址，确保 IPV6=yes 这个值生效： 1vim /etc/default/ufw 设置基本的出入站规则入站（备注，默认禁止所有端口访问，后面我们会预留必要的端口）： 1ufw default deny incoming 出站（备注，默认允许服务器访问所有端口）： 1ufw default allow outgoing 出站规则我们就不用再做其他的额外设置了，主要做入站的端口规则，打开各种必要的端口，对于我的阿里云来说，平时打开ssh登陆端口和其他访问端口就够了： 1ufw allow 22/tcp ssh登陆端口是一定要放行的，否则等会儿机器都连不上了。 在ufw里添加规则彻底禁止阿里云的检测节点IP来骚扰我们的机器： 1vim /etc/ufw/before.rules 找到 # End required lines ，添加如下： -A ufw-before-input -s 140.205.201.0/24 -j DROP-A ufw-before-input -s 140.205.201.0/28 -j DROP-A ufw-before-input -s 140.205.201.16/29 -j DROP-A ufw-before-input -s 140.205.201.32/28 -j DROP-A ufw-before-input -s 140.205.225.0/24 -j DROP-A ufw-before-input -s 140.205.225.192/29 -j DROP-A ufw-before-input -s 140.205.225.200/30 -j DROP-A ufw-before-input -s 140.205.225.184/29 -j DROP-A ufw-before-input -s 140.205.225.183/32 -j DROP-A ufw-before-input -s 140.205.225.206/32 -j DROP-A ufw-before-input -s 140.205.225.205/32 -j DROP-A ufw-before-input -s 140.205.225.195/32 -j DROP-A ufw-before-input -s 140.205.225.204/32 -j DROP-A ufw-before-input -s 106.11.224.0/26 -j DROP-A ufw-before-input -s 106.11.224.64/26 -j DROP-A ufw-before-input -s 106.11.224.128/26 -j DROP-A ufw-before-input -s 106.11.224.192/26 -j DROP-A ufw-before-input -s 106.11.222.64/26 -j DROP-A ufw-before-input -s 106.11.222.128/26 -j DROP-A ufw-before-input -s 106.11.222.192/26 -j DROP-A ufw-before-input -s 106.11.223.0/26 -j DROP-A ufw-before-input -s 112.124.127.224 -j DROP-A ufw-before-input -s 112.124.127.44 -j DROP-A ufw-before-input -s 112.124.127.64 -j DROP-A ufw-before-input -s 112.124.127.53 -j DROP-A ufw-before-input -s 120.26.216.168 -j DROP-A ufw-before-input -s 120.26.64.126 -j DROP-A ufw-before-input -s 121.43.107.174 -j DROP-A ufw-before-input -s 121.43.107.176 -j DROP-A ufw-before-input -s 121.41.117.242 -j DROP-A ufw-before-input -s 121.40.130.38 -j DROP-A ufw-before-input -s 121.41.112.148 -j DROP-A ufw-before-input -s 115.29.112.222 -j DROP-A ufw-before-input -s 115.28.203.70 -j DROP-A ufw-before-input -s 42.96.189.63 -j DROP-A ufw-before-input -s 115.29.113.101 -j DROP-A ufw-before-input -s 120.27.40.113 -j DROP-A ufw-before-input -s 115.28.171.22 -j DROP-A ufw-before-input -s 115.28.189.208 -j DROP-A ufw-before-input -s 121.42.196.232 -j DROP-A ufw-before-input -s 115.28.26.13 -j DROP-A ufw-before-input -s 120.27.47.144 -j DROP-A ufw-before-input -s 120.27.47.33 -j DROP-A ufw-before-input -s 112.126.74.55 -j DROP-A ufw-before-input -s 182.92.148.207 -j DROP-A ufw-before-input -s 182.92.1.233 -j DROP-A ufw-before-input -s 112.126.73.56 -j DROP-A ufw-before-input -s 123.56.138.37 -j DROP-A ufw-before-input -s 123.57.10.133 -j DROP-A ufw-before-input -s 112.126.75.174 -j DROP-A ufw-before-input -s 182.92.157.118 -j DROP-A ufw-before-input -s 112.126.75.221 -j DROP-A ufw-before-input -s 182.92.69.212 -j DROP-A ufw-before-input -s 10.153.174.11 -j DROP-A ufw-before-input -s 10.153.175.147 -j DROP-A ufw-before-input -s 10.153.175.146 -j DROP-A ufw-before-input -s 110.75.0.0/16 -j DROP-A ufw-before-input -s 42.120.0.0/16 -j DROP 确认、保存退出。 重载ufw配置，使其生效1ufw reload 卸载云监控Java版本插件123sudo /usr/local/cloudmonitor/wrapper/bin/cloudmonitor.sh stopsudo /usr/local/cloudmonitor/wrapper/bin/cloudmonitor.sh removesudo rm -rf /usr/local/cloudmonitor 卸载云监控 Go 语言版123sudo /usr/local/cloudmonitor/CmsGoAgent.linux-amd64 stopsudo /usr/local/cloudmonitor/CmsGoAgent.linux-amd64 uninstallsudo rm -rf /usr/local/cloudmonitor]]></content>
      <categories>
        <category>云服务器</category>
      </categories>
      <tags>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的Activities四种启动模式]]></title>
    <url>%2F2018%2F07%2F25%2FAndroid%E7%9A%84Activities%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android的Activities四种启动模式：Standerd、SingleTop、SingleTask、SingleInstance。 Standard(默认标准启动模式)每次启动都重新创建一个新的实例，不管它是否存在。且谁启动了这个Acitivity,那么这个Acitivity就运行在启动它的那个Acitivity的任务栈中。 SingleTop(栈顶复用模式)如果新的Activity已经位于任务栈的栈顶，那么不会被重新创建，而是回调onNewIntent()方法，通过此方法的参数可以取出当前请求的信息。 SingleTask(栈内复用模式)这是一种单例模式，在这种模式下，只要Acitivity在一个栈中存在，那么多次启动此Acitivity都不会重建实例，而是回调onNewIntent方法。同时由于SingleTask模式有ClearTop功能，因此会导致所要求的Acitivity上方的Acitivity全部销毁。 SingleInstance(单实例模式)和栈内复用类似，此种模式的Acitivity只能单独位于一个任务栈中。全局唯一性。单例实例，不是创建，而是重用。独占性，一个Acitivity单独运行在一个工作栈中。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android,activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是内部类？内部类的作用]]></title>
    <url>%2F2018%2F07%2F22%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[内部类基础在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。 成员内部类成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式： 1234567891011class Circle &#123; double radius = 0; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println("drawshape"); &#125; &#125;&#125; 这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 1234567891011121314class Circle &#123; private double radius = 0; public static int count =1; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 &#125; &#125;&#125; 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问： 12外部类.this.成员变量外部类.this.成员方法 虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问： 123456789101112131415161718class Circle &#123; private double radius = 0; public Circle(double radius) &#123; this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 &#125; private Draw getDrawInstance() &#123; return new Draw(); &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 &#125; &#125;&#125; 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); &#125;&#125;class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 12345678910111213141516class People&#123; public People() &#123; &#125;&#125;class Man&#123; public Man()&#123; &#125; public People getWoman()&#123; class Woman extends People&#123; //局部内部类 int age =0; &#125; return new Woman(); &#125;&#125; 注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。 匿名内部类匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码： 1234567891011121314scan_bt.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125;);history_bt.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125;); 这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的： 123456new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; 就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。 1234567891011121314151617181920private void setListener()&#123; scan_bt.setOnClickListener(new Listener1()); history_bt.setOnClickListener(new Listener2());&#125;class Listener1 implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125;class Listener2 implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; 这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); &#125;&#125;class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 深入理解内部类为什么成员内部类可以无条件访问外部类的成员在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是Outter.java的代码： 123456789101112131415public class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; protected class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 编译之后，出现了两个字节码文件： 12Outter$Inner.classOutter.class 反编译Outter$Inner.class文件得到下面信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 bill@ThinkPad:~/test$ javap -v Outter\$Inner.classClassfile /home/bill/test/Outter$Inner.class Last modified Feb 27, 2019; size 304 bytes MD5 checksum 732ba89287828251572200e940699e56 Compiled from "Outter.java"public class Outter$Inner minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Fieldref #3.#13 // Outter$Inner.this$0:LOutter; #2 = Methodref #4.#14 // java/lang/Object."&lt;init&gt;":()V #3 = Class #16 // Outter$Inner #4 = Class #19 // java/lang/Object #5 = Utf8 this$0 #6 = Utf8 LOutter; #7 = Utf8 &lt;init&gt; #8 = Utf8 (LOutter;)V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 SourceFile #12 = Utf8 Outter.java #13 = NameAndType #5:#6 // this$0:LOutter; #14 = NameAndType #7:#20 // "&lt;init&gt;":()V #15 = Class #21 // Outter #16 = Utf8 Outter$Inner #17 = Utf8 Inner #18 = Utf8 InnerClasses #19 = Utf8 java/lang/Object #20 = Utf8 ()V #21 = Utf8 Outter&#123; final Outter this$0; descriptor: LOutter; flags: ACC_FINAL, ACC_SYNTHETIC public Outter$Inner(Outter); descriptor: (LOutter;)V flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: aload_1 2: putfield #1 // Field this$0:LOutter; 5: aload_0 6: invokespecial #2 // Method java/lang/Object."&lt;init&gt;":()V 9: return LineNumberTable: line 14: 0 line 16: 9&#125;SourceFile: "Outter.java"InnerClasses: protected #17= #3 of #15; //Inner=class Outter$Inner of class Outter 第33行的内容： 1final Outter this$0; 这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器： 1public Outter$Inner(Outter); 从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。 为什么局部内部类和匿名内部类只能访问局部final变量想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码： 12345678910111213public class Test &#123; public static void main(String[] args) &#123; &#125; public void test(final int b) &#123; final int a = 10; new Thread()&#123; public void run() &#123; System.out.println(a); System.out.println(b); &#125;; &#125;.start(); &#125;&#125; 这段代码会被编译成两个class文件： 12Test.classTest$1.class 默认情况下，编译器会为匿名内部类和局部内部类起名为Outterx.class（x为正整数）。 上段代码中，如果把变量a和b前面的任一个final去掉，这段代码都编译不过。我们先考虑这样一个问题： 当test方法执行完毕之后，变量a的生命周期就结束了，而此时Thread对象的生命周期很可能还没有结束，那么在Thread的run方法中继续访问变量a就变成不可能了，但是又要实现这样的效果，怎么办呢？Java采用了 复制 的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容： 12345678910111213141516171819...public void run(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 3: bipush 10 5: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 8: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 11: aload_0 12: getfield #2 // Field val$b:I 15: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 18: return LineNumberTable: line 8: 0 line 9: 8 line 10: 18... 我们看到在run方法中有一条指令： 13: bipush 10 这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。 下面再看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; final int val$a; descriptor: I flags: ACC_FINAL, ACC_SYNTHETIC final Test this$0; descriptor: LTest; flags: ACC_FINAL, ACC_SYNTHETIC Test$1(Test, int); descriptor: (LTest;I)V flags: Code: stack=2, locals=3, args_size=3 0: aload_0 1: aload_1 2: putfield #1 // Field this$0:LTest; 5: aload_0 6: iload_2 7: putfield #2 // Field val$a:I 10: aload_0 11: invokespecial #3 // Method java/lang/Thread."&lt;init&gt;":()V 14: return LineNumberTable: line 7: 0 public void run(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_0 4: getfield #2 // Field val$a:I 7: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 10: return LineNumberTable: line 9: 0 line 10: 10&#125;SourceFile: "Test.java"EnclosingMethod: #21.#22 // Test.testInnerClasses: #6; //class Test$1 我们看到匿名内部类Test$1的构造器含有两个参数，一个是指向外部类对象的引用，一个是int型变量，很显然，这里是将变量test方法中的形参a以参数的形式传进来对匿名内部类中的拷贝（变量a的拷贝）进行赋值初始化。 也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。 从上面可以看出，在run方法中访问的变量a根本就不是test方法中的局部变量a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在run方法中访问的变量a和test方法中的变量a不是同一个变量，当在run方法中改变变量a的值的话，会出现什么情况？ 对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java编译器就限定必须将变量a限制为final变量，不允许对变量a进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。 到这里，想必大家应该清楚为何方法中的局部变量和形参都必须用final进行限定了。 静态内部类有特殊的地方吗从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译class文件看一下就知道了，是没有Outter this&amp;0引用的。 123456789101112131415public class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142bill@ThinkPad:~/test$ javap -v Outter\$Inner.classClassfile /home/bill/test/Outter$Inner.class Last modified Feb 27, 2019; size 247 bytes MD5 checksum 49f1ac59bf30823652c62cfb3807f21e Compiled from "Outter.java"class Outter$Inner minor version: 0 major version: 52 flags: ACC_SUPERConstant pool: #1 = Methodref #3.#10 // java/lang/Object."&lt;init&gt;":()V #2 = Class #12 // Outter$Inner #3 = Class #15 // java/lang/Object #4 = Utf8 &lt;init&gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 SourceFile #9 = Utf8 Outter.java #10 = NameAndType #4:#5 // "&lt;init&gt;":()V #11 = Class #16 // Outter #12 = Utf8 Outter$Inner #13 = Utf8 Inner #14 = Utf8 InnerClasses #15 = Utf8 java/lang/Object #16 = Utf8 Outter&#123; public Outter$Inner(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 12: 0 line 13: 4&#125;SourceFile: "Outter.java"InnerClasses: static #13= #2 of #11; //Inner=class Outter$Inner of class Outter 内部类的使用场景和好处为什么在Java中需要内部类？总结一下主要有以下四点： 每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整 方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏 方便编写事件驱动程序 方便编写线程代码 个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善 常见的与内部类相关的笔试面试题根据注释填写(1)，(2)，(3)处的代码12345678910111213141516171819202122232425public class Solution&#123; public static void main(String[] args)&#123; // 初始化Bean1 //(1) bean1.I++; // 初始化Bean2 //(2) bean2.J++; //初始化Bean3 //(3) bean3.k++; &#125; class Bean1&#123; public int I = 0; &#125; static class Bean2&#123; public int J = 0; &#125;&#125;class Bean&#123; class Bean3&#123; public int k = 0; &#125;&#125; 答案： 123456789101112131415161718192021222324252627282930313233public class Solution&#123; public static void main(String[] args)&#123; // 初始化Bean1 //(1) Solution mySolution = new Solution(); Bean1 bean1 = mySolution.new Bean1(); bean1.I++; // 初始化Bean2 //(2) Bean2 bean2 = new Solution.Bean2(); bean2.J++; //初始化Bean3 //(3) Bean bean = new Bean(); Bean.Bean3 bean3 = bean.new Bean3(); bean3.k++; &#125; class Bean1&#123; public int I = 0; &#125; static class Bean2&#123; public int J = 0; &#125;&#125;class Bean&#123; class Bean3&#123; public int k = 0; &#125;&#125; 从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。 创建静态内部类对象的一般形式为： 外部类类名.内部类类名 xxx = new 外部类类名.内部类类名() 创建成员内部类对象的一般形式为： 外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名() 下面这段代码的输出结果是什么123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; Outter outter = new Outter(); outter.new Inner().print(); &#125;&#125;class Outter&#123; private int a = 1; class Inner &#123; private int a = 2; public void print() &#123; int a = 3; System.out.println("局部变量：" + a); System.out.println("内部类变量：" + this.a); System.out.println("外部类变量：" + Outter.this.a); &#125; &#125;&#125; 123321 最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点： 成员内部类的引用方式必须为 Outter.Inner. 构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》 123456789101112131415class WithInner &#123; class Inner&#123; &#125;&#125;class InheritInner extends WithInner.Inner &#123; // InheritInner() 是不能通过编译的，一定要加上形参 InheritInner(WithInner wi) &#123; wi.super(); //必须有这句调用 &#125; public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner obj = new InheritInner(wi); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu网络配置]]></title>
    <url>%2F2018%2F07%2F16%2FJava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1.单例类只能有一个实例 2.单例类必须自己创建自己的唯一实例 3.单例类必须给所有其他对象提供这一实例 介绍意 图： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。主要解决： 一个全局使用的类频繁地创建与销毁。何时使用：当您想控制实例数目，节省系统资源的时候。如何解决： 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。关键代码： 构造函数是私有的。应用实例： 1.一个党只能有一个主席。 2.Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3.一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。优点： 1.在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2.避免对资源的多重占用（比如写文件操作）。缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。使用场景： 1.要求生产唯一序列号。2.WEB中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3.创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。注意事项： getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。核心知识点如下： 1.将采用单例设计模式的类的构造方法私有化（采用private修饰）。2.在其内部产生该类的实例化对象，并将其封装成private static类型。3.定义一个静态方法返回该类的实例。 单例模式的几种实现方式懒汉式，线程不安全是否 Lazy 初始化： 是是否多线程安全： 否实现难度： 易描述： 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 懒汉式，线程安全是否 Lazy 初始化： 是是否多线程安全： 是实现难度： 易描述： 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点： 第一次调用才初始化，避免内存浪费。缺点： 必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123; &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 饿汉式是否 Lazy 初始化： 否是否多线程安全： 是实现难度： 易描述： 这种方式比较常用，但容易产生垃圾对象。优点： 没有加锁，执行效率会提高。缺点： 类加载时就初始化，浪费内存。它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 双检锁/双重校验锁（DCL，即 double-checked locking）JDK 版本： JDK1.5 起是否 Lazy 初始化： 是是否多线程安全： 是实现难度： 较复杂描述： 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。123456789101112131415public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton != null) &#123; return singleton; &#125; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; return singleton; &#125; &#125; 登记式/静态内部类是否 Lazy 初始化： 是是否多线程安全： 是实现难度： 一般描述： 这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 枚举JDK 版本： JDK1.5 起是否 Lazy 初始化： 否是否多线程安全： 是实现难度： 易描述： 这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 经验之谈： 一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu,网络配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu中安装和美化ZSH Shell]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%9C%A8Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96ZSH%20Shell%2F</url>
    <content type="text"><![CDATA[ZSH 或称 Z Shell 是一个类似于 Bash 和 SH 的 Linux Shell，它具有一些 Bash 和其它 Shell 不具备的高级功能。流行的 Git 版本控制系统也可以使用插件与 ZSH 很好的集成，这一点对软件开发人员来说非常有用。而且 ZSH 有非常多的主题和插件支持，比 Bash 更具可定制性。简单来说，ZSH 就是一款替代 Bash 且非常好用的 Linux Shell。 安装ZSH Shell12sudo apt updatesudo apt install zsh 设置为默认Shell12whereis zshsudo usermod -s /usr/bin/zsh $(whoami) 现在使用 reboot 或 init 6 命令重新启动 Ubuntu 计算机。 重启后，打开终端，输入数字 2，ZSH 会使用推荐的设置创建一个新的 ~/.zshrc 配置文件，此后就可以正常使用 ZSH Shell 了。 安装Powerline和Powerline字体「Powerline」是 ZSH Shell 的状态行插件，「Powerline 字体」也允许 ZSH 在 Shell 中使用不同的图标和符号。而「Powerline」和「Powerline 字体」也可以在 Ubuntu 的官方软件包存储库中找到。 1sudo apt install powerline fonts-powerline ZSH、Git与「Oh My ZSH」集成安装 Git 1sudo apt install git Git 安装好之后，请执行以下命令在 Ubuntu 系统中安装「Oh My ZSH」 1sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 注意：安装「Oh My ZSH」会自动更改 ~/.zshrc 配置文件，这意味着安装的 ZSH Syntax Highlighting 插件将会被禁用。可以在「Oh My ZSH」安装好之后执行zsh的相关命令，重新启用 ZSH Syntax Highlighting 插件。 启用语法高亮显示使用它可以突出显示 ZSH Shell 中的命令 1sudo apt install zsh-syntax-highlighting 将/usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh目录下在读文件复制到~/.oh-my-zsh/plugins/zsh-syntax-highlighting目录下，然后编辑~/.zshrc文件，在最末尾加入source ~/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh。 打开一个新的「终端」窗口开始输入命令，应该就可以看到命令以不同的颜色突出、高亮显示。 自动补齐插件下载此插件，插件官网 12cd /tempwget http://mimosa-pudica.net/src/incr-0.2.zsh 将此插件放到oh-my-zsh目录的插件库下 ~/.oh-my-zsh/plugins/incr。 在~/.zshrc文件末尾加上 1source ~/.oh-my-zsh/plugins/incr/incr-0.2.zsh 更新配置1source ~/.zshrc 优化zsh的配置修改~/.zshrc文件 12# zhs的主题ZSH_THEME="ys" 1234# z命令快速跳转目录 x命令解压一切文件 命令行可以直接google plugins=( git z zsh-autosuggestions extract web-search zsh-syntax-highlighting ) 与vim的提示相冲突的解决方案使用自动补全插件可能会与vim的提示功能相冲突，如会报以下错误： 12vim t_arguments:451: _vim_files: function definition file not found 解决方法：将~/.zcompdump*删除即可 12rm -rf ~/.zcompdump*exec zsh]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu常用设置]]></title>
    <url>%2F2018%2F06%2F16%2FUbuntu%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Ubuntu 18.10 安装之后需要做的 事，下面会列出系统安装之后需要做的一些事，这将使得 Ubuntu 的体验更加出色。 安装更新12sudo apt updatesudo apt upgrade 启用「点击Ubuntu Dock最小化」在 Ubuntu 18.10 中点击应用程序「最小化」按钮可以隐藏到 Ubuntu Dock 栏图标，再点击 Ubuntu Dock 栏中的图标时可以还原界面。但在默认情况下，点击 Ubuntu Dock 图标却无法将应用程序界面最小化。 1gsettings set org.gnome.shell.extensions.dash-to-dock click-action 'minimize' 显示电池百分比1gsettings set org.gnome.desktop.interface show-battery-percentage true 用TLP降低发热TLP 是一个有助于「系统冷却」的应用程序，可以让 Ubuntu 运行得更快、更顺畅。安装完成后，运行命令启动它即可，而无需任何配置。 1234sudo add-apt-repository ppa:linrunner/tlpsudo apt updatesudo apt install tlp tlp-rdwsudo tlp start 设置软件更新镜像Ubuntu 的软件源配置文件是 /etc/apt/sources.list，确保 Ubuntu 从最佳服务器获取更新，建议使用清华大学开源镜像站的软件源镜像 Ubuntu 18.10 123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-security main restricted universe multiverse 使用apt-fast取代apt-get如果您希望下载速度更快，可以安装apt-fast并在使用apt-get命令的地方用apt-fast来替换。 123sudo add-apt-repository ppa:apt-fast/stablesudo apt-get updatesudo apt-get install apt-fast 清理Ubuntu12sudo apt clean #只删除过时的软件包sudo apt autoremove #清理整个缓存 安装Nvidia显卡驱动123sudo add-apt-repository ppa:graphics-drivers/ppasudo apt-get updatesudo apt-fast install nvidia-390 nvidia-settings nvidia-prime 安装完成后需要重启。 安装PreloadPreload（预加载）会在后台工作，以「研究」您如何使用计算机并增强计算机的应用程序处理能力。安装好 Preload 后，您使用频率最高的应用程序的加载速度就会明显快于不经常使用的应用程序。 1sudo apt install preload 清理缩略图缓存1du -sh ~/.cache/thumbnails 卸载不必要的应用程序1sudo apt remove 软件包名 获取WiFi无线密码1cd /etc/NetworkManager/system-connections #此目录中存储了网络连接详细信息的配置文件，可以使用ls命令列出所有 WiFi 连接配置文件。 使用 cat 命令查看 Linux 中已保存的 WiFi 配置文件，在 WiFi-Security 段的 psk 位置可以查看到无线密码。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditText显示明文与密码]]></title>
    <url>%2F2018%2F05%2F12%2FEditText%E6%98%BE%E7%A4%BA%E6%98%8E%E6%96%87%E4%B8%8E%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[第一种方法 123456789101112131415161718private void initListener() &#123; mCbDisplayPassword.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked) &#123; mEtPassword.setInputType(InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD); &#125; else &#123; mEtPassword.setInputType(InputType.TYPE_CLASS_TEXT|InputType.TYPE_NUMBER_VARIATION_PASSWORD); &#125; &#125; &#125;); &#125; 第二种方法123456789101112131415161718private void initListener()&#123; mCbDisplayPassword.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked) &#123; mEtPassword.setTransformationMethod(HideReturnsTransformationMethod.getInstance()); &#125; else &#123; mEtPassword.setTransformationMethod(PasswordTransformationMethod.getInstance()); &#125; &#125; &#125;);&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>EditText,密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android拍照，适配到Android7.0]]></title>
    <url>%2F2018%2F04%2F19%2FAndroid%E6%8B%8D%E7%85%A7%EF%BC%8C%E9%80%82%E9%85%8D%E5%88%B0Android7.0%2F</url>
    <content type="text"><![CDATA[获得相机权限因为需要用到camera，所以需要在manifest 文件里面声明设备 需要安装有camera程序。 12345&lt;manifest ... &gt; &lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt; ...&lt;/manifest&gt; 获得缩略图Anroid相机程序将通过onActivityResult() 返回 Bitmap缩略图 12345678@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data)&#123; if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123; Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get("data"); mImageView.setImageBitmap(imageBitmap); &#125;&#125; 注意： 从“data”从获取来的缩略图只适合作为icon，不适合其他用途。 保存大尺寸图片一般用户应该将通过相机拍摄的照片保存在公共外部存储目录，这样可以方便其他应用程序访问。 getExternalStoragePublicDirectory()方法和 DIRECTORY_PICTURES参数可以将公共照片保存在正确的目录，因为这种方法提供的目录是所有应用程序之间共享，各自需要READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限。如果允许了写的权限，那么读的权限也将被隐式允许。所以，如果你需要读写外部存取目录，你只需要声明一个权限。 12345&lt;manifest ...&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; ...&lt;/manifest&gt; 然而，如果你想将照片保存到私有目录只供你的app使用，那么你可以使用getExternalFilesDir()方法。在Android4.3及以下，仍需要WRITE_EXTERNAL_STORAGE 权限；但是从Android4.4开始，就不再需要声明此权限了，因为这个目录无法被其他app访问。因此你可以这样声明权限，仅仅只在较低的版本上添加maxSdkVersion属性： 12345&lt;manifest ...&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="18" /&gt; ...&lt;/manifest&gt; 注意： 用getExternalFilesDir()和 getFilesDir()方法保存在目录的文件，会随着用户卸载app而一并删除。 以下是谷歌提供的生成唯一文件名的一种方法 1234567891011121314151617String mCurrentPhotoPath;private File createImageFile() throws IOException &#123; // Create an image file name String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()); String imageFileName = "JPEG_" + timeStamp + "_"; File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES); File image = File.createTempFile( imageFileName, /* prefix */ ".jpg", /* suffix */ storageDir /* directory */ ); // Save a file: path for use with ACTION_VIEW intents mCurrentPhotoPath = image.getAbsolutePath(); return image;&#125; 然后调用Intent 启动相机 123456789101112131415161718192021222324static final int REQUEST_TAKE_PHOTO = 1;private void dispatchTakePictureIntent() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); // Ensure that there's a camera activity to handle the intent if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; // Create the File where the photo should go File photoFile = null; try &#123; photoFile = createImageFile(); &#125; catch (IOException ex) &#123; // Error occurred while creating the File ... &#125; // Continue only if the File was successfully created if (photoFile != null) &#123; Uri photoURI = FileProvider.getUriForFile(this, "com.example.android.fileprovider", photoFile); takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI); startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO); &#125; &#125;&#125; 注意： 从Android7.0开始，通过getUriForFile(Context, String, File) 返回的content:// URI来访问数据，使用过去的file://URI将产生FileUriExposedException异常，现在一般使用FileProvider这种更加通用的方式来存储文件。 配置FileProvider在清单文件中：12345678910111213&lt;application&gt; ... &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.example.android.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"&gt;&lt;/meta-data&gt; &lt;/provider&gt; ...&lt;/application&gt; 必须确保android:authorities里面的值和class文件中的 getUriForFile(Context, String, File) 方法的值保持一致。exported:要求必须为false，为true则会报安全异常。grantUriPermissions:true，表示授予 URI 临时访问权限。为了指定共享的目录我们需要在资源(res)目录下创建一个xml目录，然后创建一个名为“file_paths”(名字可以随便起，只要和在manifest注册的provider所引用的resource保持一致即可)的资源文件。 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="my_images" path="Android/data/com.example.package.name/files/Pictures" /&gt;&lt;/paths&gt; 上述代码中path=&quot;&quot;，是有特殊意义的，它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为path=&quot;pictures&quot;，那么它代表着根目录下的pictures目录(eg:/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的。 将图片保存到相册注意： 如果你是用getExternalFilesDir()方法保存的文件，那么媒体将无法扫描到，因为它只对你的app私有化。 12345678private void galleryAddPic() &#123; Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); File f = new File(mCurrentPhotoPath); Uri contentUri = Uri.fromFile(f); mediaScanIntent.setData(contentUri); this.sendBroadcast(mediaScanIntent);&#125; 按比例缩小图片123456789101112131415161718192021222324private void setPic() &#123; // Get the dimensions of the View int targetW = mImageView.getWidth(); int targetH = mImageView.getHeight(); // Get the dimensions of the bitmap BitmapFactory.Options bmOptions = new BitmapFactory.Options(); bmOptions.inJustDecodeBounds = true; BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); int photoW = bmOptions.outWidth; int photoH = bmOptions.outHeight; // Determine how much to scale down the image int scaleFactor = Math.min(photoW/targetW, photoH/targetH); // Decode the image file into a Bitmap sized to fill the View bmOptions.inJustDecodeBounds = false; bmOptions.inSampleSize = scaleFactor; bmOptions.inPurgeable = true; Bitmap bitmap = BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); mImageView.setImageBitmap(bitmap);&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android,拍照,android7.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的adb调试命令集合]]></title>
    <url>%2F2018%2F03%2F17%2FAndroid%E7%9A%84adb%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[一些实用的命令发送广播关闭USB1adb shell am broadcast -a android.hardware.usb.action.USB_STATE --ez connected "false" 关闭gyroscope(陀螺仪) 硬件相关，可能有变动 1adb shell echo 0 &gt; /sys/class/sensors/bmg160/enable 无线adb连接手机Connect the device to the computer with a USB cable → The computer recognize the device 1adb devices Make sure device’s Wifi is ON, and set device’s tcpip port → To change the adb port 1adb tcpip 12443 Write down the device IP (Connect to wifi): Go to settings → about phone → Status → IP addressExample: 192.168.8.81 1adb connect 192.168.8.81:12443 Disconnect the cable 1adb disconnect 192.168.8.81:12443 查看系统时间1adb shell date 开机跳过setupWizard正常使用disable SetupWizard:12adb shell pm list packages | grep setupadb shell pm disable → Example: com.google.android.setupwizard build Provision and push into handset:12mmm packages/apps/Provision/adb push out/target/product/flash3/system/app/Provision/Provision.apk /system/app/Provision/ reboot1adb reboot Provision就是无界面版的SetupWizard，快速设置并初始化手机，是SetupWizard的替代版。 可断开USB还执行adb命令，例如通过如下命令记录event log到sdcard 1adb shell "getevent -ltr &gt; sdcard/getevent.log&amp;" (linux common function) 在执行此命令之后可拔掉USB进行测试 查看Notification：“找出状态栏广告的主人”1adb shell dumpsys statusbar debug相关的命令过滤log篇只查看某个TAG的某个priority的log：1adb logcat ActivityManager:I MyApp:D *:S *:S: sets the priority level for all tags to “silent”, thus ensuring only log messages with “ActivityManager” and “MyApp” are displayed. 只显示Error级别的log：1adb logcat *:E 直接看Exception的命令：1adb logcat -s */E logcat时可以查看某个tag的所有log:1adb logcat -v threadtime -s [TAG] 打开某个class的log：1adb shell setprop log.tag.MyAppTag VERBOSE or: Creating a local.prop file as described in the original question: log.tag.MY_TAG=VERBOSE And then pushing it onto the device as follows seems to do the trick: adb push local.prop /data/local.prop adb shell chmod 644 /data/local.prop adb shell chown root.root /data/local.prop adb reboot You can double check to make sure that the values in local.prop were read by executing:adb shell getprop | grep log.tag 抓取kernel log：1adb shell cat /proc/kmsg &gt; kernel.log 强制让进程gc1adb shell kill -10 PIDXXX 强制生成trace /data/anr/traces.txt 1adb shell kill -3 PIDxxx 强制生成进程的内存镜像 分析OOM 1adb shell am dumpheap PIDxxx /data/xxx.hprof 打印调用顺序 在java代码中加入，可知道该函数被谁调用 1Debug.getCallers(4) top命令 每隔1秒执行top命令显示10行数据，能够实时查看后台哪些进程或者线程在执 行，消耗cpu 1adb shell top -d 1 -m 10 -t 软重新启动1adb shell stop; adb shell start monkey test的命令12adb shell monkey -v -p [package name] [times]adb shell monkey -v -p com.jrdcom.lockscreen 1000000 查看cpu频率1234adb shell cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freqadb shell cat /sys/devices/system/cpu/cpu1/cpufreq/scaling_cur_freqadb shell cat /sys/devices/system/cpu/cpu2/cpufreq/scaling_cur_freqadb shell cat /sys/devices/system/cpu/cpu3/cpufreq/scaling_cur_freq 打开CPU loading log 分析ANR（MTK） 1adb shell setprop events.cpu true 在events log中实时打印cpu信息。 123456adb logcat -b events | grep cpu I/cpu ( 743): [16,4,12,0,0,0] I/cpu ( 743): [15,2,13,0,0,0] I/cpu ( 743): [16,2,14,0,0,0]数字都是百分比，分别为：[total, user, system, iouat, irq, softlrq] 终端输入play pause事件模拟按键12345678adb shell media usage: media [subcommand] [options] media dispatch KEY media remote-display media dispatch: dispatch a media key to the current media client. KEY may be: play, pause, play-pause, mute, headsethook, stop, next, previous, rewind, recordm fast-forword. media remote-display: monitor remote display updates. 系列核心命令模拟输入事件1234adb shell input text &lt;string&gt; input a string to deviceadb shell input keyevent &lt;event_code&gt; send a Key Event to device如: adb shell input keyevent 26 (PowerKey) 模拟启动activity123adb shell am start &lt;INTENT&gt; : start an Activity如：am start -n com.android.calculator/com.android.calculator2.Calculatoradb shell am broadcast &lt;INTENT&gt; 得到设置的settings数据库键值 usage: settings [–user NUM] get namespace key ​ settings [–user NUM] put namespace key value ​ settings [–user NUM] delete namespace key ‘namespace’ is one of {system, secure, global}, case-insensitive If ‘–user NUM’ is not given, the operations are performed on the owner user. 1adb shell settings get/set Global airplane_mode_on 修改数据库的键值12adb shell settings put system/global [key] [value]adb shell settings put system navigation_bar_key_mode 1 得到数据库的键值1adb shell settings get system/global [key] 查看Service信息查看Service列表123adb shell service list Found 1 services:0 phone: [com.android.internal.telephony.ITelephony] 检查Service是否存在12adb shell service check phoneService phone: found 使用Service1adb shell service call phone 2 s16 "10086" 手机屏幕相关设置-wm命令 adb shell wm usage: wm [subcommand] [options] ​ wm size [reset | WxH] ​ wm density [reset | DENSITY] ​ wm overscan [reset | LEFT,TOP,RIGHT,BOTTOM] wm overscan [reset|LEFT,TOP,RIGHT,BOTTOM]wm overscan: set overscan area for display. 重新设置屏幕大小、尺寸: 让界面显示在靠左200，靠上300，靠右400，靠下500的显示区域 width = displaywidth - left - right height = displayheight - top - bottom 12adb shell wm overscan 200,300,400,500 left,top,right,bottom wm size: return or override display size查看屏幕分辨率 12adb shell wm size Physical size: 720x1280 wm density: override display density12adb shell wm density Physical density: 480 强制设置手机dpi为320 12adb shell wm density 320adb shell wm density reset svc命令Turn on/off Wi-Fi1svc wifi [enable|disable] Turn on/off mobile data1svc data [enable|disable] 手机重启12svc power reboot [reason] Perform a runtime shutdown and reboot device with specified reason. 手机关机12svc power shutdown Perform a runtime shutdown and power off the device. pm 命令大全 pm命令用于分析手机中apk和包名 查看当前安装的所有apk1adb shell pm list packages 查看包名和文件名对应表12345adb shell pm list packages -f package:/system/priv-app/DefaultContainerService.apk=com.android.defcontainer package:/data/app/com.tencent.mm-1.apk=com.tencent.mm package:/system/app/JrdGallery.apk=com.jrdcom.gallery3d ... 查看disable packagename1adb shell pm list packages -d 查看enable packagename1adb shell pm list packages -e 查看system app packagename1adb shell pm list packages -s 查看第三方app packagename1adb shell pm list packages -3 其他12345adb shell pm list features# Enable/Disable packageadb shell pm enable [packagename]adb shell pm disable [packagename] am 命令大全强制dump某个进程的内存镜像12# 1044是Launcher的pidadb shell am dumpheap 1044 /data/aa.hprof Dalvik’s sampling profiler 定时抓取java call stack12345adb shell am profile start [--user &lt;USER_ID&gt; current] [--sampling INTERVAL] &lt;PROCESS&gt; &lt;FILE&gt;adb shell am profile stop [--user &lt;USER_ID&gt; current] [&lt;PROCESS&gt;]persist.sys.profiler_ms 时间频率 默认0persist.sys.profiler_depth call stack depth 默认4抓取的文件保存于/data/snapshots/&lt;pid&gt;-&lt;time&gt;.snapshot List all of the activity stacks and their sizes1adb shell am stack list Display the information about activity stack1adb shell am stack info &lt;STACK_ID&gt; dumpsys相关命令查看activity的provider信息查看activity每个数据库的调用信息查询 打印所有provider信息 可以查看数据库某个时间点的增删改查的次数, 监测应用的IO操作: 12345678910adb shell dumpsys activity provider allPROVIDER ContentProviderRecord&#123;19861e6e u0 com.android.providers.media/.MediaProvider&#125; pid=31295 Client: internal.db: version 700, 68 rows, 0 inserts, 0 updates, 0 deletes, 120 queries, 1970-02-07 10:49:01.893 : Database upgraded from version 63 to 700 in 0 seconds 插入62次，0次更新，0次删除，105次查询 1970-02-07 10:49:03.852 : internal.db: version 700, 54 rows, 62 inserts, 0 updates, 0 deletes, 105 queries, scan started Feb 7, 10:49 AM (00:02) 1970-02-07 10:54:06.555 : internal.db: version 700, 54 rows, 0 inserts, 0 updates, 0 deletes, 55 queries, scan started 2月7日 下午6:54 (00:00) 2013-12-26 05:41:19.318 : internal.db: version 700, 54 rows, 0 inserts, 4 updates, 0 deletes, 58 queries, scan started Dec 26, 1:41 PM (00:00) 2013-12-27 07:45:37.775 : internal.db: version 700, 59 rows, 0 inserts, 0 updates, 0 deletes, 55 queries, scan started Dec 27, 3:45 PM (00:00) 查看provider的Connections，谁在连接数据库1dumpsys activity providers 查看手机disk状态12345adb shell dumpsys diskstats &gt;&gt; Latency: 5ms [512B Data Write] &gt;&gt; Data-Free: 362888K / 1161104K total = 31% free &gt;&gt; Cache-Free: 116756K / 120900K total = 96% free &gt;&gt; System-Free: 133036K / 806284K total = 16% free Get the list of services available1adb shell service list 查看可用的SERVICE列表1234567891011121314adb shell dumpsys | grep 'DUMP OF SERVICE' | awk '&#123;print $4&#125;' | tr -d ':'ACTIVITY MANAGER PENDING INTENTS (adb shell dumpsys activity intents)ACTIVITY MANAGER BROADCAST STATE (adb shell dumpsys activity broadcasts)ACTIVITY MANAGER CONTENT PROVIDERS (adb shell dumpsys activity providers)ACTIVITY MANAGER SERVICES (adb shell dumpsys activity services)ACTIVITY MANAGER ACTIVITIES (adb shell dumpsys activity activities)ACTIVITY MANAGER RUNNING PROCESSES (adb shell dumpsys activity processes)INPUT MANAGER (adb shell dumpsys input)WINDOW MANAGER LAST ANR (adb shell dumpsys window lastanr)WINDOW MANAGER POLICY STATE (adb shell dumpsys window policy)WINDOW MANAGER SESSIONS (adb shell dumpsys window sessions)WINDOW MANAGER TOKENS (adb shell dumpsys window tokens)WINDOW MANAGER WINDOWS (adb shell dumpsys window windows) 查看某个应用的内存使用信息 getting memory usage informations 12adb shell dumpsys meminfo 'your apps package name'adb shell dumpsys meminfo com.google.android.apps.maps 查看TaskStack1adb shell dumpsys activity activities 查看Alarm列表1adb shell dumpsys alarm 查看surface flinger1adb shell dumpsys SurfaceFlinger dumpsys其他一些信息123456789101112131415adb shell dumpsys SurfaceFlinger | grep "Layer\|z="adb shell dumpsys activity log a onadb shell dumpsys window -d enable 26adb shell dumpsys alarm log onadb shell dumpsys alarm log offadb shell dumpsys window policyadb shell dumpsys activity log anr 2 可以打开anr的messagequeueadb shell dumpsys activity a 查看activity详细信息，如显示大小，布局等等adb shell dumpsys activity processes 进程信息 trimmemoryadb shell dumpsys activity recentsadb shell dumpsys activity broadcasts 可以查看前台和后台broadcast详细信息(发送时间， 所有应用处理时间，监听广播的所有列表)adb shell dumpsys activity intentsadb shell dumpsys activity oomadb shell dumpsys input | grep Focus 查看焦点窗口]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android,adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用笔记]]></title>
    <url>%2F2018%2F03%2F17%2FGit%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[设置配置12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址 创建SSH Key1$ ssh-keygen -t rsa -C "youremail@example.com" 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 测试是否可以正常连接1ssh -T git@git.coding.net #Coding 1ssh -T git@github.com #Github 设置Git代理12git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080 取消Git代理12git config --global --unset http.proxygit config --global --unset https.proxy]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git,设置</tag>
      </tags>
  </entry>
</search>

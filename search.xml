<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中==和equals和hashCode的区别]]></title>
    <url>%2F2019%2F03%2F13%2FJava%E4%B8%AD%3D%3D%E5%92%8Cequals%E5%92%8ChashCode%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java中的数据类型 基本数据类型，也称原始数据类型 byte、short、char、int、long、float、double、boolean 他们之间的比较，应用双等号（==），比较的是他们的值。 引用类型(类、接口、数组) 当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 对象是放在堆中的，栈中存放的是对象的引用（地址）。由此可见“==”是对栈中的值进行比较的。如果要比较堆中对象的内容是否相同，那么就要重写equals方法了。 123456789101112131415161718192021222324252627282930public class Solution &#123; public static void main(String[] args) &#123; int int1 = 12; int int2 = 12; Integer Integer1 = new Integer(12); Integer Integer2 = new Integer(12); Integer Integer3 = new Integer(127); Integer a1 = 127; Integer b1 = 127; Integer a = 128; Integer b = 128; String s1 = "str"; String s2 = "str"; String str1 = new String("str"); String str2 = new String("str"); System.out.println("int1==int2:" + (int1 == int2)); System.out.println("int1==Integer1:" + (int1 == Integer1)); System.out.println("Integer1==Integer2:" + (Integer1 == Integer2)); System.out.println("Integer3==b1:" + (Integer3 == b1)); System.out.println("a1==b1:" + (a1 == b1)); System.out.println("a==b:" + (a == b)); System.out.println("s1==s2:" + (s1 == s2)); System.out.println("s1==str1:" + (s1 == str1)); System.out.println("str1==str2:" + (str1 == str2)); &#125;&#125; 输出： 123456789int1==int2:trueint1==Integer1:true //Integer会自动拆箱为int，所以为trueInteger1==Integer2:false //不同对象，在内存存放地址不同，所以为falseInteger3==b1:false //Integer3指向new的对象地址，b1指向缓存中127地址，地址不同，所以为falsea1==b1:truea==b:falses1==s2:trues1==str1:falsestr1==str2:false Integer b1 = 127；java在编译的时候，被翻译成-&gt;Integer b1 = Integer.valueOf(127)； 123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 对于-128到127之间的数，会进行缓存，Integer b1 = 127时，会将127进行缓存，下次再写Integer i6 = 127时，就会直接从缓存中取，就不会new了。所以 a1==b1:true a==b:false。 Java中的equals方法解析默认情况（没有覆盖equals方法）下equals方法都是调用Object类的equals方法，而Object的equals方法主要用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。下面是Object类中equals方法， 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 定义的equals与==是等效的 要是类中覆盖了equals方法，那么就要根据具体的代码来确定equals方法的作用了，覆盖后一般都是通过对象的内容是否相等来判断对象是否相等。下面是String类对equals进行了重写； 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = count; if (n == anotherString.count) &#123; char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n-- != 0) &#123; if (v1[i++] != v2[j++]) return false; &#125; return true; &#125; &#125; return false;&#125; 即String中equals方法判断相等的步骤是： 若A==B 即是同一个String对象 返回true 若对比对象是String类型则继续，否则返回false 判断A、B长度是否一样，不一样的话返回false 逐个字符比较，若有不相等字符，返回false 这里对equals重新需要注意五点： 自反性：对任意引用值x，x.equals(x)的返回值一定为true。 对称性：对于任何引用值x、y，当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true。 传递性：如果x.equals(y)=true， y.equals(z)=true，则x.equals(z)=true。 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变。 非空性：任何非空的引用值X，x.equals(null)的返回值一定为false。 实现高质量equals方法的诀窍： 使用==符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。 使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。 把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。 对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。 当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。 hashCode方法解析hashCode()方法返回的就是一个数值，从方法的名称上就可以看出，其目的是生成一个hash码。hash码的主要用途就是在对对象进行散列的时候作为key输入，据此很容易推断出，我们需要每个对象的hash码尽可能不同，这样才能保证散列的存取性能。事实上，Object类提供的默认实现确实保证每个对象的hash码不同（在对象的内存地址基础上经过特定算法返回一个hash码）。Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。 哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。初学者可以这样理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。 散列函数、散列算法、哈希函数是一种从任何一种数据中创建小的数字“指纹”的方法。 散列函数将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。 好的散列函数在输入域中很少出现散列冲突。 所有散列函数都有如下一个基本特性： 如果a=b，则h(a) = h(b)。 如果a!=b，则h(a)与h(b)可能得到相同的散列值。 Object 的hashCode方法：返回一个int类型 1public native int hashCode(); hashCode的作用 想要明白，必须要先知道Java中的集合。总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 于是，Java采用了哈希表的原理。 这样一来，当集合要添加新的元素时， 先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 eqauls方法和hashCode方法关系Java对于eqauls方法和hashCode方法是这样规定的： 同一对象上多次调用hashCode()方法，总是返回相同的整型值。 如果a.equals(b)，则一定有a.hashCode() 一定等于 b.hashCode()。 如果!a.equals(b)，则a.hashCode() 不一定等于b.hashCode()。此时如果a.hashCode() 总是不等于 b.hashCode()，会提高hashtables的性能。 a.hashCode()==b.hashCode() 则 a.equals(b)可真可假。 a.hashCode()！= b.hashCode() 则 a.equals(b)为假。 上面结论简记： 如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。 如果两个对象不equals，他们的hashcode有可能相等。 如果两个对象hashcode相等，他们不一定equals。 如果两个对象hashcode不相等，他们一定不equals。 关于这两个方法的重要规范： 若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该相等”。不过请注意：这个只是规范，如果你非要写一个类让equals(Object obj)返回true而hashcode()返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG。 如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashcode可能相同”。 为什么覆盖equals时总要覆盖hashCode一个很常见的错误根源在于没有覆盖hashCode方法。在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。 在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。 如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。 如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。 总结 equals方法用于比较对象的内容是否相等（覆盖以后） hashcode方法只有在集合中用到 当覆盖了equals方法时，比较对象是否相等将通过覆盖后的equals方法进行比较（判断对象的内容是否相等） 将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java,hashcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的next主题个性化教程]]></title>
    <url>%2F2019%2F02%2F15%2FHexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[设置中文修改配置文件(_config.yml) 1language: zh-Hans 酷炫的动态背景打开\themes\NexT\_config.yml，修改以下内容： 123456789101112131415161718# 背景特效以下4项，是NexT主题集成的，只需将 false 改为 true，即可启用# 不用向网上说的，到模板文件里加引用js的脚本，NexT已经集成了，开启即用# Canvas-nest 浮动线条canvas_nest: enable: true onmobile: true # display on mobile or not color: '0,0,255' # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines# three_waves 水波粒子three_waves: false# canvas_lines 这个是一根线连接两个小点，组成的一个随鼠标放大缩小的东西canvas_lines: false# canvas_sphere 这个是一个很多刺组成的一个球canvas_sphere: false 主页文章添加阴影效果打开themes/next/source/css/_custom/custom.styl文件添加： 1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 启用：页面加载过程中顶部的进度条打开\themes\NexT\_config.yml，找到字段 pace，设为true。还可以将pace_theme:的值，改成相应的名字,变更不同样式的加载条。 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记在路径\themes\next\layout\_macro中新建 passage-end-tag.swig 文件，并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV），代码如下：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml)，在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 主页文章添加阴影效果打开\themes\next\source\css\_custom\custom.styl，向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 设置网站的图标Favicon一张（32*32）的ico图标，或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 在文章底部增加版权信息在目录 next/layout/_macro/下添加 my-copyright.swig： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import "my-post-copyright" 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置 如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加： 1234567---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright:--- 这样每次hexo new “你的内容”之后，生成的md文件会自动把copyright:加到里面去 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig，注释或者直接删除以下代码： 1234567891011121314151617&#123;% if theme.footer.powered.enable %&#125; &lt;div class="powered-by"&gt;&#123;# #&#125;&#123;&#123; __('footer.powered', next_url('https://hexo.io', 'Hexo', &#123;class: 'theme-link'&#125;)) &#125;&#125;&#123;# #&#125;&#123;% if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env('version') &#125;&#125;&#123;% endif %&#125;&#123;# #&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered.enable and theme.footer.theme.enable %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class="theme-info"&gt;&#123;# #&#125;&#123;&#123; __('footer.theme') &#125;&#125; – &#123;&#123; next_url('https://theme-next.org', 'NexT.' + theme.scheme, &#123;class: 'theme-link'&#125;) &#125;&#125;&#123;# #&#125;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 添加站内搜索安装hexo-generator-searchdb插件 1npm install hexo-generator-searchdb --save 编辑_config.yml站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑themes/next/_config.yml 主题配置文件，启用本地搜索功能,将local_search:下面的enable:的值，改成true 123# Local searchlocal_search: enable: true 首页不显示全文(只显示预览)打开主题配置文件/themes/next/_config.yml，将auto_excerpt下面的enable:的值，改成true 12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt:enable: truelength: 150 除了这个方法，还有一个更灵活的方法，直接在编辑的文章中添加标记。这样只会显示标记之前的那部份。 添加打赏功能打开themes/next/_config.yml站点配置文件，找到# Reward把wechatpay:和alipay:前面的#号删除。然后将自己的二维码文件wechatpay.jpg、alipay.jpg图片放入themes/next/source/images中即可。 12345# Rewardreward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png Hexo载入动画效果编辑themes/netx/_config.yml找到motion,将enable的值，改成true 123456789101112131415161718# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn #号里都是载入效果，有时间可以自己多试一试！ 美化右侧滚动条打开themes\next\source\css\_custom\custom.styl文件，将下面的代码添加进去。 12345678910111213141516171819202122//设置滚动条的样式//参考https://segmentfault.com/a/1190000003708894::-webkit-scrollbar &#123; width: 5px; height: 5px;&#125;//滚动槽::-webkit-scrollbar-track &#123; background: #eee;&#125;//滚动条滑块::-webkit-scrollbar-thumb &#123; border-radius: 5px; background-color: #ccc;&#125;::-webkit-scrollbar-thumb:hover &#123; background-color: rgb(247, 149, 51);&#125; 优化鼠标选择文字的样式打开themes\next\source\css\_custom\custom.styl文件，将下面的代码添加进去。 12345::selection &#123; background-color: rgb(255, 241, 89); color: #555;&#125; 网页中文乱码解决办法所有配置文件都可以用记事本打开，如果输入中文后网页显示乱码，则需要将该文件另存为utf-8编码文件 即打开后点击左上角 文件—&gt;另存为，然后在弹出的窗口下方有一个 编码 的下拉菜单，点击选择UTF-8选项，然后点击保存，会提示 是否替换，选择 是 即可。以后出现中文乱码问题都这样解决 设置侧边栏头像将头像图片放在主题目录的source/images/目录下，尺寸是正方形即可，然后将照片改名为avatar.jpg，或者其他后缀名的图片。编辑 主题配置文件，找到关键字avatar，删掉前面的#号，值设置成头像的链接地址，比如 1avatar: /images/avatar.jpg 保存后可用hexo s打开本地服务器预览一下效果 修改链接样式在themes\next\source\css\_common\components\post\post.styl在末尾添加如下css样式： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;]]></content>
      <categories>
        <category>next主题</category>
      </categories>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int、char、long各占多少字节数]]></title>
    <url>%2F2018%2F12%2F17%2Fint%E3%80%81char%E3%80%81long%E5%90%84%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[123456789public static void main(String[] args) &#123; System.out.println(Byte.SIZE); System.out.println(Character.SIZE); System.out.println(Short.SIZE); System.out.println(Integer.SIZE); System.out.println(Float.SIZE); System.out.println(Double.SIZE); System.out.println(Long.SIZE);&#125; 输出： 12345678161632326464 type size description byte 1字节 最小值是 -128（-2^7）；最大值是 127（2^7-1） boolean 至少1字节 这种类型只作为一种标志来记录 true/false 情况 short 2字节 最小值是 -32768（-2^15）；最大值是 32767（2^15 - 1） char 2字节 最小值是 \u0000（即为0）；最大值是 \uffff（即为65,535） int 4字节 最小值是 -2,147,483,648（-2^31）；最大值是 2,147,483,647（2^31^ - 1） float 4字节 单精度浮点数字长32位，尾数长度23，指数长度8,指数偏移量127 long 8字节 最小值是 -9,223,372,036,854,775,808（-2^63）；最大值是 9,223,372,036,854,775,807（2^63 -1） double 8字节 双精度浮点数字长64位，尾数长度52，指数长度11，指数偏移量1023 英文字母： 字节数 : 1，编码：GB2312 字节数 : 1，编码：GBK 字节数 : 1，编码：ISO-8859-1 字节数 : 1，编码：UTF-8 中文汉字： 字节数 : 2，编码：GB2312 字节数 : 2，编码：GBK 字节数 : 1，编码：ISO-8859-1 字节数 : 3，编码：UTF-8]]></content>
      <categories>
        <category>基本数据类型</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int与integer的区别]]></title>
    <url>%2F2018%2F11%2F15%2Fint%E4%B8%8Einteger%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Integer是int的包装类，int则是java的一种基本数据类型 Integer变量必须实例化后才能使用，而int变量不需要 Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 Integer的默认值是null，int的默认值是0 关于Integer和int的比较 由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 123Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） 123Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） 123Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false 123456Integer i = 100;Integer j = 100;System.out.print(i == j); //trueInteger i = 128;Integer j = 128;System.out.print(i == j); //false 对于第4条的原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下： 1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了]]></content>
      <categories>
        <category>基本数据类型</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer、StringBuilder区别]]></title>
    <url>%2F2018%2F10%2F28%2FString%2CStringBuffer%2CStringBuilder%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[可变性String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。 线程安全性String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。 性能每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结： 如果要操作少量的数据用 = String 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 多线程操作字符串缓冲区 下操作大量数据 = StringBuffer]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>string区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio配置]]></title>
    <url>%2F2018%2F10%2F01%2FAndroid%20Studio%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[当我首次使用Android Studio的时候，会采用如下配置，下面的一些配置技巧或许对你有一定的帮助。 显示行号 File | Settings 打开设置 选择 Editor | General | Appearance 勾选 Show line numbers 命名前缀 File | Settings 打开设置 选择 Editor | Code Style | Java 选择 Code Generation 标签 给普通 Field 添加一个 m 前缀，给 Static filed 添加一个 s 前缀 快速导包 File | Settings 打开设置 选择 Editor | General | Auto Import 勾选 Optimize imports on the fly 勾选 Add unambiguous imports on the fly Logcat 颜色 File | Settings 打开设置 选择 Editor | Color &amp; Fonts | Android Logcat 点击 Click on Save As…按钮创建一个新的配色 Scheme 按照下面的表格修改对应的颜色(修改之前需要取消勾选 Use inherited attributes) Logcat级别 颜色 Assert #AA66CC Debug #33B5E5 Error #FF4444 Info #99CC00 Verbose #FFFFFF Warning #FFBB33 代码配色 File | Settings 打开设置 选择 Editor | Color &amp; Fonts | Java 点击 Click on Save As…按钮创建一个新的配色 Scheme 展开下方的 Variables 选择 Local variable 设置右侧的 Foreground 颜色 #68B5EE 字体设置 File | Settings 打开设置 选择 Editor | Font 设置右侧的 Font 选择Consolas，Size选择14 文件编码设置 File | Settings 打开设置 选择 Editor | File Encodings 设置右侧的 Global Encoding、Project Encoding、Default encoding for properties files 为 UTF-8 显示快速文档 File | Settings 打开设置 选择 Editor | General 勾选 Show quick documentation on mouse move 设置启动项 File | Settings 打开设置 选择 Appearance &amp; Behavior | System Settings 取消勾选 Reopen last project on startup 和 Confirm application exit 选择 Open project in new window]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈对java多态的理解]]></title>
    <url>%2F2018%2F09%2F28%2F%E8%B0%88%E8%B0%88%E5%AF%B9java%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[运行时多态性是面向对象程序设计代码重用的一个最强大机制，Java多态性的概念也可以被说成“一个接口，多个方法”。Java实现运行时多态性的基础是动态方法调度，它是一种在运行时而不是在编译期调用重载方法的机制。 方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中Java多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 （但是如果强制把超类转换成子类的话，就可以调用子类中新添加而超类没有的方法了。）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用泛型简化findViewById]]></title>
    <url>%2F2018%2F09%2F26%2F%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%AE%80%E5%8C%96findViewById%2F</url>
    <content type="text"><![CDATA[简化findViewById在Android开发中，通过findViewById来引用资源文件的view，但是资源文件的view过多会导致做很多重复性的工作，代码很冗余，开发效率随之下降。为了减少重复书写findViewById的次数，我们可以这么来写。 12345678910public final class ViewUtils &#123; public static &lt;T extends View&gt; T findViewById(Activity activity,int resId)&#123; return (T) activity.findViewById(resId); &#125; public static &lt;T extends View&gt; T findViewById(View view,int resId)&#123; return (T) view.findViewById(resId); &#125;&#125; 通过使用泛型，可以避免了每次都进行类型转换，很大程度的简化了代码，开发效率也随之提升了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>泛型,引用资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome书签备份到Coding]]></title>
    <url>%2F2018%2F09%2F19%2FChrome%E4%B9%A6%E7%AD%BE%E5%A4%87%E4%BB%BD%E5%88%B0Coding%2F</url>
    <content type="text"><![CDATA[说明此处实现了 自动备份，可以自己设置备份间隔的时间，因为上传到 Github的方法类似，这里就不多说了。 此处先进入到Chrome的安装目录，在chrome上右键找到文件位置即可。然后进入上一级目录，到User Data目录下，在进入Default目录，其中Bookmarks文件就是书签文件，打开记事本，复制粘贴下述代码，保存为bat文件，双击即可，实现备份。打开Task Scheduler程序（windows自带），新建任务，设置每天的开始备份时间，间隔时间即可。 12345cd C:\Users\JustMe\AppData\Local\Google\Chrome\User Data\Defaultgit add Bookmarksgit commit -m "%date:~0,4%-%date:~5,2%-%date:~8,2% %time:~0,2%:%time:~3,2%:%time:~6,2%"git push origin masterpause 注意仓库添加key指纹，否则无法提交。]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>chrome,备份,书签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的Activities四种启动模式]]></title>
    <url>%2F2018%2F07%2F25%2FAndroid%E7%9A%84Activities%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android的Activities四种启动模式：Standerd、SingleTop、SingleTask、SingleInstance。 Standard(默认标准启动模式)每次启动都重新创建一个新的实例，不管它是否存在。且谁启动了这个Acitivity,那么这个Acitivity就运行在启动它的那个Acitivity的任务栈中。 SingleTop(栈顶复用模式)如果新的Activity已经位于任务栈的栈顶，那么不会被重新创建，而是回调onNewIntent()方法，通过此方法的参数可以取出当前请求的信息。 SingleTask(栈内复用模式)这是一种单例模式，在这种模式下，只要Acitivity在一个栈中存在，那么多次启动此Acitivity都不会重建实例，而是回调onNewIntent方法。同时由于SingleTask模式有ClearTop功能，因此会导致所要求的Acitivity上方的Acitivity全部销毁。 SingleInstance(单实例模式)和栈内复用类似，此种模式的Acitivity只能单独位于一个任务栈中。全局唯一性。单例实例，不是创建，而是重用。独占性，一个Acitivity单独运行在一个工作栈中。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是内部类？内部类的作用]]></title>
    <url>%2F2018%2F07%2F22%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[内部类基础在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。 成员内部类成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式： 1234567891011class Circle &#123; double radius = 0; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println("drawshape"); &#125; &#125;&#125; 这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 1234567891011121314class Circle &#123; private double radius = 0; public static int count =1; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 &#125; &#125;&#125; 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问： 12外部类.this.成员变量外部类.this.成员方法 虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问： 123456789101112131415161718class Circle &#123; private double radius = 0; public Circle(double radius) &#123; this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 &#125; private Draw getDrawInstance() &#123; return new Draw(); &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 &#125; &#125;&#125; 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); &#125;&#125;class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 12345678910111213141516class People&#123; public People() &#123; &#125;&#125;class Man&#123; public Man()&#123; &#125; public People getWoman()&#123; class Woman extends People&#123; //局部内部类 int age =0; &#125; return new Woman(); &#125;&#125; 注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。 匿名内部类匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码： 1234567891011121314scan_bt.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125;);history_bt.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125;); 这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的： 123456new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; 就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。 1234567891011121314151617181920private void setListener()&#123; scan_bt.setOnClickListener(new Listener1()); history_bt.setOnClickListener(new Listener2());&#125;class Listener1 implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125;class Listener2 implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; 这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); &#125;&#125;class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 深入理解内部类为什么成员内部类可以无条件访问外部类的成员在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是Outter.java的代码： 123456789101112131415public class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; protected class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 编译之后，出现了两个字节码文件： 12Outter$Inner.classOutter.class 反编译Outter$Inner.class文件得到下面信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 bill@ThinkPad:~/test$ javap -v Outter\$Inner.classClassfile /home/bill/test/Outter$Inner.class Last modified Feb 27, 2019; size 304 bytes MD5 checksum 732ba89287828251572200e940699e56 Compiled from "Outter.java"public class Outter$Inner minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Fieldref #3.#13 // Outter$Inner.this$0:LOutter; #2 = Methodref #4.#14 // java/lang/Object."&lt;init&gt;":()V #3 = Class #16 // Outter$Inner #4 = Class #19 // java/lang/Object #5 = Utf8 this$0 #6 = Utf8 LOutter; #7 = Utf8 &lt;init&gt; #8 = Utf8 (LOutter;)V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 SourceFile #12 = Utf8 Outter.java #13 = NameAndType #5:#6 // this$0:LOutter; #14 = NameAndType #7:#20 // "&lt;init&gt;":()V #15 = Class #21 // Outter #16 = Utf8 Outter$Inner #17 = Utf8 Inner #18 = Utf8 InnerClasses #19 = Utf8 java/lang/Object #20 = Utf8 ()V #21 = Utf8 Outter&#123; final Outter this$0; descriptor: LOutter; flags: ACC_FINAL, ACC_SYNTHETIC public Outter$Inner(Outter); descriptor: (LOutter;)V flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: aload_1 2: putfield #1 // Field this$0:LOutter; 5: aload_0 6: invokespecial #2 // Method java/lang/Object."&lt;init&gt;":()V 9: return LineNumberTable: line 14: 0 line 16: 9&#125;SourceFile: "Outter.java"InnerClasses: protected #17= #3 of #15; //Inner=class Outter$Inner of class Outter 第33行的内容： 1final Outter this$0; 这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器： 1public Outter$Inner(Outter); 从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。 为什么局部内部类和匿名内部类只能访问局部final变量想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码： 12345678910111213public class Test &#123; public static void main(String[] args) &#123; &#125; public void test(final int b) &#123; final int a = 10; new Thread()&#123; public void run() &#123; System.out.println(a); System.out.println(b); &#125;; &#125;.start(); &#125;&#125; 这段代码会被编译成两个class文件： 12Test.classTest$1.class 默认情况下，编译器会为匿名内部类和局部内部类起名为Outterx.class（x为正整数）。 上段代码中，如果把变量a和b前面的任一个final去掉，这段代码都编译不过。我们先考虑这样一个问题： 当test方法执行完毕之后，变量a的生命周期就结束了，而此时Thread对象的生命周期很可能还没有结束，那么在Thread的run方法中继续访问变量a就变成不可能了，但是又要实现这样的效果，怎么办呢？Java采用了 复制 的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容： 12345678910111213141516171819...public void run(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 3: bipush 10 5: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 8: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 11: aload_0 12: getfield #2 // Field val$b:I 15: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 18: return LineNumberTable: line 8: 0 line 9: 8 line 10: 18... 我们看到在run方法中有一条指令： 13: bipush 10 这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。 下面再看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; final int val$a; descriptor: I flags: ACC_FINAL, ACC_SYNTHETIC final Test this$0; descriptor: LTest; flags: ACC_FINAL, ACC_SYNTHETIC Test$1(Test, int); descriptor: (LTest;I)V flags: Code: stack=2, locals=3, args_size=3 0: aload_0 1: aload_1 2: putfield #1 // Field this$0:LTest; 5: aload_0 6: iload_2 7: putfield #2 // Field val$a:I 10: aload_0 11: invokespecial #3 // Method java/lang/Thread."&lt;init&gt;":()V 14: return LineNumberTable: line 7: 0 public void run(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_0 4: getfield #2 // Field val$a:I 7: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 10: return LineNumberTable: line 9: 0 line 10: 10&#125;SourceFile: "Test.java"EnclosingMethod: #21.#22 // Test.testInnerClasses: #6; //class Test$1 我们看到匿名内部类Test$1的构造器含有两个参数，一个是指向外部类对象的引用，一个是int型变量，很显然，这里是将变量test方法中的形参a以参数的形式传进来对匿名内部类中的拷贝（变量a的拷贝）进行赋值初始化。 也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。 从上面可以看出，在run方法中访问的变量a根本就不是test方法中的局部变量a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在run方法中访问的变量a和test方法中的变量a不是同一个变量，当在run方法中改变变量a的值的话，会出现什么情况？ 对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java编译器就限定必须将变量a限制为final变量，不允许对变量a进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。 到这里，想必大家应该清楚为何方法中的局部变量和形参都必须用final进行限定了。 静态内部类有特殊的地方吗从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译class文件看一下就知道了，是没有Outter this&amp;0引用的。 123456789101112131415public class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142bill@ThinkPad:~/test$ javap -v Outter\$Inner.classClassfile /home/bill/test/Outter$Inner.class Last modified Feb 27, 2019; size 247 bytes MD5 checksum 49f1ac59bf30823652c62cfb3807f21e Compiled from "Outter.java"class Outter$Inner minor version: 0 major version: 52 flags: ACC_SUPERConstant pool: #1 = Methodref #3.#10 // java/lang/Object."&lt;init&gt;":()V #2 = Class #12 // Outter$Inner #3 = Class #15 // java/lang/Object #4 = Utf8 &lt;init&gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 SourceFile #9 = Utf8 Outter.java #10 = NameAndType #4:#5 // "&lt;init&gt;":()V #11 = Class #16 // Outter #12 = Utf8 Outter$Inner #13 = Utf8 Inner #14 = Utf8 InnerClasses #15 = Utf8 java/lang/Object #16 = Utf8 Outter&#123; public Outter$Inner(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 12: 0 line 13: 4&#125;SourceFile: "Outter.java"InnerClasses: static #13= #2 of #11; //Inner=class Outter$Inner of class Outter 内部类的使用场景和好处为什么在Java中需要内部类？总结一下主要有以下四点： 每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整 方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏 方便编写事件驱动程序 方便编写线程代码 个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善 常见的与内部类相关的笔试面试题根据注释填写(1)，(2)，(3)处的代码12345678910111213141516171819202122232425public class Solution&#123; public static void main(String[] args)&#123; // 初始化Bean1 //(1) bean1.I++; // 初始化Bean2 //(2) bean2.J++; //初始化Bean3 //(3) bean3.k++; &#125; class Bean1&#123; public int I = 0; &#125; static class Bean2&#123; public int J = 0; &#125;&#125;class Bean&#123; class Bean3&#123; public int k = 0; &#125;&#125; 答案： 123456789101112131415161718192021222324252627282930313233public class Solution&#123; public static void main(String[] args)&#123; // 初始化Bean1 //(1) Solution mySolution = new Solution(); Bean1 bean1 = mySolution.new Bean1(); bean1.I++; // 初始化Bean2 //(2) Bean2 bean2 = new Solution.Bean2(); bean2.J++; //初始化Bean3 //(3) Bean bean = new Bean(); Bean.Bean3 bean3 = bean.new Bean3(); bean3.k++; &#125; class Bean1&#123; public int I = 0; &#125; static class Bean2&#123; public int J = 0; &#125;&#125;class Bean&#123; class Bean3&#123; public int k = 0; &#125;&#125; 从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。 创建静态内部类对象的一般形式为： 外部类类名.内部类类名 xxx = new 外部类类名.内部类类名() 创建成员内部类对象的一般形式为： 外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名() 下面这段代码的输出结果是什么123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; Outter outter = new Outter(); outter.new Inner().print(); &#125;&#125;class Outter&#123; private int a = 1; class Inner &#123; private int a = 2; public void print() &#123; int a = 3; System.out.println("局部变量：" + a); System.out.println("内部类变量：" + this.a); System.out.println("外部类变量：" + Outter.this.a); &#125; &#125;&#125; 123321 最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点： 成员内部类的引用方式必须为 Outter.Inner. 构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》 123456789101112131415class WithInner &#123; class Inner&#123; &#125;&#125;class InheritInner extends WithInner.Inner &#123; // InheritInner() 是不能通过编译的，一定要加上形参 InheritInner(WithInner wi) &#123; wi.super(); //必须有这句调用 &#125; public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner obj = new InheritInner(wi); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1.单例类只能有一个实例 2.单例类必须自己创建自己的唯一实例 3.单例类必须给所有其他对象提供这一实例 介绍意 图： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。主要解决： 一个全局使用的类频繁地创建与销毁。何时使用：当您想控制实例数目，节省系统资源的时候。如何解决： 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。关键代码： 构造函数是私有的。应用实例： 1.一个党只能有一个主席。 2.Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3.一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。优点： 1.在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2.避免对资源的多重占用（比如写文件操作）。缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。使用场景： 1.要求生产唯一序列号。2.WEB中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3.创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。注意事项： getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。核心知识点如下： 1.将采用单例设计模式的类的构造方法私有化（采用private修饰）。2.在其内部产生该类的实例化对象，并将其封装成private static类型。3.定义一个静态方法返回该类的实例。 单例模式的几种实现方式懒汉式，线程不安全是否 Lazy 初始化： 是是否多线程安全： 否实现难度： 易描述： 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 懒汉式，线程安全是否 Lazy 初始化： 是是否多线程安全： 是实现难度： 易描述： 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点： 第一次调用才初始化，避免内存浪费。缺点： 必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123; &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 饿汉式是否 Lazy 初始化： 否是否多线程安全： 是实现难度： 易描述： 这种方式比较常用，但容易产生垃圾对象。优点： 没有加锁，执行效率会提高。缺点： 类加载时就初始化，浪费内存。它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 双检锁/双重校验锁（DCL，即 double-checked locking）JDK 版本： JDK1.5 起是否 Lazy 初始化： 是是否多线程安全： 是实现难度： 较复杂描述： 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 登记式/静态内部类是否 Lazy 初始化： 是是否多线程安全： 是实现难度： 一般描述： 这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 枚举JDK 版本： JDK1.5 起是否 Lazy 初始化： 否是否多线程安全： 是实现难度： 易描述： 这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 经验之谈： 一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java,单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu中安装和美化ZSH Shell]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%9C%A8Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96ZSH%20Shell%2F</url>
    <content type="text"><![CDATA[ZSH 或称 Z Shell 是一个类似于 Bash 和 SH 的 Linux Shell，它具有一些 Bash 和其它 Shell 不具备的高级功能。流行的 Git 版本控制系统也可以使用插件与 ZSH 很好的集成，这一点对软件开发人员来说非常有用。而且 ZSH 有非常多的主题和插件支持，比 Bash 更具可定制性。简单来说，ZSH 就是一款替代 Bash 且非常好用的 Linux Shell。 安装ZSH Shell12sudo apt updatesudo apt install zsh 设置为默认Shell12whereis zshsudo usermod -s /usr/bin/zsh $(whoami) 现在使用 reboot 或 init 6 命令重新启动 Ubuntu 计算机。 重启后，打开终端，输入数字 2，ZSH 会使用推荐的设置创建一个新的 ~/.zshrc 配置文件，此后就可以正常使用 ZSH Shell 了。 安装Powerline和Powerline字体「Powerline」是 ZSH Shell 的状态行插件，「Powerline 字体」也允许 ZSH 在 Shell 中使用不同的图标和符号。而「Powerline」和「Powerline 字体」也可以在 Ubuntu 的官方软件包存储库中找到。 1sudo apt install powerline fonts-powerline ZSH、Git与「Oh My ZSH」集成安装 Git 1sudo apt install git Git 安装好之后，请执行以下命令在 Ubuntu 系统中安装「Oh My ZSH」 1sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 注意：安装「Oh My ZSH」会自动更改 ~/.zshrc 配置文件，这意味着安装的 ZSH Syntax Highlighting 插件将会被禁用。可以在「Oh My ZSH」安装好之后执行zsh的相关命令，重新启用 ZSH Syntax Highlighting 插件。 启用语法高亮显示使用它可以突出显示 ZSH Shell 中的命令 1sudo apt install zsh-syntax-highlighting 将/usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh目录下在读文件复制到~/.oh-my-zsh/plugins/zsh-syntax-highlighting目录下，然后编辑~/.zshrc文件，在最末尾加入source ~/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh。 打开一个新的「终端」窗口开始输入命令，应该就可以看到命令以不同的颜色突出、高亮显示。 自动补齐插件下载此插件，插件官网 12cd /tempwget http://mimosa-pudica.net/src/incr-0.2.zsh 将此插件放到oh-my-zsh目录的插件库下 ~/.oh-my-zsh/plugins/incr。 在~/.zshrc文件末尾加上 1source ~/.oh-my-zsh/plugins/incr/incr-0.2.zsh 更新配置1source ~/.zshrc 优化zsh的配置修改~/.zshrc文件 12# zhs的主题ZSH_THEME="ys" 1234# z命令快速跳转目录 x命令解压一切文件 命令行可以直接google plugins=( git z zsh-autosuggestions extract web-search zsh-syntax-highlighting ) 与vim的提示相冲突的解决方案使用自动补全插件可能会与vim的提示功能相冲突，如会报以下错误： 12vim t_arguments:451: _vim_files: function definition file not found 解决方法：将~/.zcompdump*删除即可 12rm -rf ~/.zcompdump*exec zsh]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu常用设置]]></title>
    <url>%2F2018%2F06%2F16%2FUbuntu%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Ubuntu 18.10 安装之后需要做的 事，下面会列出系统安装之后需要做的一些事，这将使得 Ubuntu 的体验更加出色。 安装更新12sudo apt updatesudo apt upgrade 启用「点击Ubuntu Dock最小化」在 Ubuntu 18.10 中点击应用程序「最小化」按钮可以隐藏到 Ubuntu Dock 栏图标，再点击 Ubuntu Dock 栏中的图标时可以还原界面。但在默认情况下，点击 Ubuntu Dock 图标却无法将应用程序界面最小化。 1gsettings set org.gnome.shell.extensions.dash-to-dock click-action 'minimize' 显示电池百分比1gsettings set org.gnome.desktop.interface show-battery-percentage true 用TLP降低发热TLP 是一个有助于「系统冷却」的应用程序，可以让 Ubuntu 运行得更快、更顺畅。安装完成后，运行命令启动它即可，而无需任何配置。 1234sudo add-apt-repository ppa:linrunner/tlpsudo apt updatesudo apt install tlp tlp-rdwsudo tlp start 设置软件更新镜像Ubuntu 的软件源配置文件是 /etc/apt/sources.list，确保 Ubuntu 从最佳服务器获取更新，建议使用清华大学开源镜像站的软件源镜像 Ubuntu 18.10 123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-security main restricted universe multiverse 使用apt-fast取代apt-get如果您希望下载速度更快，可以安装apt-fast并在使用apt-get命令的地方用apt-fast来替换。 123sudo add-apt-repository ppa:apt-fast/stablesudo apt-get updatesudo apt-get install apt-fast 清理Ubuntu12sudo apt clean #只删除过时的软件包sudo apt autoremove #清理整个缓存 安装Nvidia显卡驱动123sudo add-apt-repository ppa:graphics-drivers/ppasudo apt-get updatesudo apt-fast install nvidia-390 nvidia-settings nvidia-prime 安装完成后需要重启。 安装PreloadPreload（预加载）会在后台工作，以「研究」您如何使用计算机并增强计算机的应用程序处理能力。安装好 Preload 后，您使用频率最高的应用程序的加载速度就会明显快于不经常使用的应用程序。 1sudo apt install preload 清理缩略图缓存1du -sh ~/.cache/thumbnails 卸载不必要的应用程序1sudo apt remove 软件包名 获取WiFi无线密码1cd /etc/NetworkManager/system-connections #此目录中存储了网络连接详细信息的配置文件，可以使用ls命令列出所有 WiFi 连接配置文件。 使用 cat 命令查看 Linux 中已保存的 WiFi 配置文件，在 WiFi-Security 段的 psk 位置可以查看到无线密码。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditText显示明文与密码]]></title>
    <url>%2F2018%2F05%2F12%2FEditText%E6%98%BE%E7%A4%BA%E6%98%8E%E6%96%87%E4%B8%8E%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[第一种方法 123456789101112131415161718private void initListener() &#123; mCbDisplayPassword.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked) &#123; mEtPassword.setInputType(InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD); &#125; else &#123; mEtPassword.setInputType(InputType.TYPE_CLASS_TEXT|InputType.TYPE_NUMBER_VARIATION_PASSWORD); &#125; &#125; &#125;); &#125; 第二种方法123456789101112131415161718private void initListener()&#123; mCbDisplayPassword.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked) &#123; mEtPassword.setTransformationMethod(HideReturnsTransformationMethod.getInstance()); &#125; else &#123; mEtPassword.setTransformationMethod(PasswordTransformationMethod.getInstance()); &#125; &#125; &#125;);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>EditText,密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android拍照，适配到Android7.0]]></title>
    <url>%2F2018%2F04%2F19%2FAndroid%E6%8B%8D%E7%85%A7%EF%BC%8C%E9%80%82%E9%85%8D%E5%88%B0Android7.0%2F</url>
    <content type="text"><![CDATA[获得相机权限因为需要用到camera，所以需要在manifest 文件里面声明设备 需要安装有camera程序。 12345&lt;manifest ... &gt; &lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt; ...&lt;/manifest&gt; 获得缩略图Anroid相机程序将通过onActivityResult() 返回 Bitmap缩略图 12345678@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data)&#123; if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123; Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get("data"); mImageView.setImageBitmap(imageBitmap); &#125;&#125; 注意： 从“data”从获取来的缩略图只适合作为icon，不适合其他用途。 保存大尺寸图片一般用户应该将通过相机拍摄的照片保存在公共外部存储目录，这样可以方便其他应用程序访问。 getExternalStoragePublicDirectory()方法和 DIRECTORY_PICTURES参数可以将公共照片保存在正确的目录，因为这种方法提供的目录是所有应用程序之间共享，各自需要READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限。如果允许了写的权限，那么读的权限也将被隐式允许。所以，如果你需要读写外部存取目录，你只需要声明一个权限。 12345&lt;manifest ...&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; ...&lt;/manifest&gt; 然而，如果你想将照片保存到私有目录只供你的app使用，那么你可以使用getExternalFilesDir()方法。在Android4.3及以下，仍需要WRITE_EXTERNAL_STORAGE 权限；但是从Android4.4开始，就不再需要声明此权限了，因为这个目录无法被其他app访问。因此你可以这样声明权限，仅仅只在较低的版本上添加maxSdkVersion属性： 12345&lt;manifest ...&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="18" /&gt; ...&lt;/manifest&gt; 注意： 用getExternalFilesDir()和 getFilesDir()方法保存在目录的文件，会随着用户卸载app而一并删除。 以下是谷歌提供的生成唯一文件名的一种方法 1234567891011121314151617String mCurrentPhotoPath;private File createImageFile() throws IOException &#123; // Create an image file name String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()); String imageFileName = "JPEG_" + timeStamp + "_"; File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES); File image = File.createTempFile( imageFileName, /* prefix */ ".jpg", /* suffix */ storageDir /* directory */ ); // Save a file: path for use with ACTION_VIEW intents mCurrentPhotoPath = image.getAbsolutePath(); return image;&#125; 然后调用Intent 启动相机 123456789101112131415161718192021222324static final int REQUEST_TAKE_PHOTO = 1;private void dispatchTakePictureIntent() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); // Ensure that there's a camera activity to handle the intent if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; // Create the File where the photo should go File photoFile = null; try &#123; photoFile = createImageFile(); &#125; catch (IOException ex) &#123; // Error occurred while creating the File ... &#125; // Continue only if the File was successfully created if (photoFile != null) &#123; Uri photoURI = FileProvider.getUriForFile(this, "com.example.android.fileprovider", photoFile); takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI); startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO); &#125; &#125;&#125; 注意： 从Android7.0开始，通过getUriForFile(Context, String, File) 返回的content:// URI来访问数据，使用过去的file://URI将产生FileUriExposedException异常，现在一般使用FileProvider这种更加通用的方式来存储文件。 配置FileProvider在清单文件中：12345678910111213&lt;application&gt; ... &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.example.android.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"&gt;&lt;/meta-data&gt; &lt;/provider&gt; ...&lt;/application&gt; 必须确保android:authorities里面的值和class文件中的 getUriForFile(Context, String, File) 方法的值保持一致。exported:要求必须为false，为true则会报安全异常。grantUriPermissions:true，表示授予 URI 临时访问权限。为了指定共享的目录我们需要在资源(res)目录下创建一个xml目录，然后创建一个名为“file_paths”(名字可以随便起，只要和在manifest注册的provider所引用的resource保持一致即可)的资源文件。 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="my_images" path="Android/data/com.example.package.name/files/Pictures" /&gt;&lt;/paths&gt; 上述代码中path=&quot;&quot;，是有特殊意义的，它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为path=&quot;pictures&quot;，那么它代表着根目录下的pictures目录(eg:/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的。 将图片保存到相册注意： 如果你是用getExternalFilesDir()方法保存的文件，那么媒体将无法扫描到，因为它只对你的app私有化。 12345678private void galleryAddPic() &#123; Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); File f = new File(mCurrentPhotoPath); Uri contentUri = Uri.fromFile(f); mediaScanIntent.setData(contentUri); this.sendBroadcast(mediaScanIntent);&#125; 按比例缩小图片123456789101112131415161718192021222324private void setPic() &#123; // Get the dimensions of the View int targetW = mImageView.getWidth(); int targetH = mImageView.getHeight(); // Get the dimensions of the bitmap BitmapFactory.Options bmOptions = new BitmapFactory.Options(); bmOptions.inJustDecodeBounds = true; BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); int photoW = bmOptions.outWidth; int photoH = bmOptions.outHeight; // Determine how much to scale down the image int scaleFactor = Math.min(photoW/targetW, photoH/targetH); // Decode the image file into a Bitmap sized to fill the View bmOptions.inJustDecodeBounds = false; bmOptions.inSampleSize = scaleFactor; bmOptions.inPurgeable = true; Bitmap bitmap = BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); mImageView.setImageBitmap(bitmap);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android,拍照,Android7.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用笔记]]></title>
    <url>%2F2018%2F03%2F17%2Fgit%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[初次运行 Git 前的配置12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址 创建SSH Key1$ ssh-keygen -t rsa -C "youremail@example.com" 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 测试是否可以正常连接1ssh -T git@git.coding.net #Coding 1ssh -T git@github.com #Github]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git,设置</tag>
      </tags>
  </entry>
</search>
